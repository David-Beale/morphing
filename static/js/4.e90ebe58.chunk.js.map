{"version":3,"sources":["../node_modules/three-bas/dist/bas.module.js"],"names":["BaseAnimationMaterial","parameters","uniforms","uniformValues","console","warn","Object","keys","forEach","key","setValues","UniformsUtils","merge","setUniformValues","values","value","name","this","join","ShaderMaterial","StandardAnimationMaterial","ShaderLib","lights","extensions","derivatives","vertexShader","concatVertexShader","fragmentShader","concatFragmentShader","standard","replace","stringifyChunk","InstancedPrefabBufferGeometry","BufferGeometry","prefab","count","prefabGeometry","copy","instanceCount","prefabCount","itemSize","factory","buffer","Float32Array","attribute","InstancedBufferAttribute","setAttribute","data","i","setPrefabData","prefabIndex","offset","attributes","j","array","InstancedBufferGeometry","Utils","geometry","face","v","a","vertices","b","c","Vector3","x","y","z","ShaderChunk","catmull_rom_spline","cubic_bezier","ease_back_in","ease_back_in_out","ease_back_out","ease_bezier","ease_bounce_in","ease_bounce_in_out","ease_bounce_out","ease_circ_in","ease_circ_in_out","ease_circ_out","ease_cubic_in","ease_cubic_in_out","ease_cubic_out","ease_elastic_in","ease_elastic_in_out","ease_elastic_out","ease_expo_in","ease_expo_in_out","ease_expo_out","ease_quad_in","ease_quad_in_out","ease_quad_out","ease_quart_in","ease_quart_in_out","ease_quart_out","ease_quint_in","ease_quint_in_out","ease_quint_out","ease_sine_in","ease_sine_in_out","ease_sine_out","quadratic_bezier","quaternion_rotation","quaternion_slerp","TimelineSegment","start","duration","transition","compiler","trail","Timeline","timeKey","segments","__key","prototype","compile","defineProperty","get","segmentDefinitions","register","definition","add","transitions","positionOffset","_eval","eval","undefined","Math","max","length","processTransition","from","defaultFrom","to","push","toString","fillGaps","s","s0","s1","end","getTransformCalls","t","map","TimelineChunks","n","p","toPrecision","w","segment","ease","easeParams","startTime","endTime","TranslationSegment","ScaleSegment","origin","RotationSegment","fromAxisAngle","Vector4","axis","angle","toAxis","toAxisAngle"],"mappings":"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","file":"static/js/4.e90ebe58.chunk.js","sourcesContent":["import { ShaderMaterial, UniformsUtils, ShaderLib, RGBADepthPacking, BufferGeometry, BufferAttribute, InstancedBufferGeometry, InstancedBufferAttribute, Vector3, Math as Math$1, Vector4 } from 'three';\n\nclass BaseAnimationMaterial extends ShaderMaterial {\n  constructor (parameters, uniforms) {\n    super();\n\n    if (parameters.uniformValues) {\n      console.warn('THREE.BAS - `uniformValues` is deprecated. Put their values directly into the parameters.');\n\n      Object.keys(parameters.uniformValues).forEach((key) => {\n        parameters[key] = parameters.uniformValues[key];\n      });\n\n      delete parameters.uniformValues;\n    }\n\n    // copy parameters to (1) make use of internal #define generation\n    // and (2) prevent 'x is not a property of this material' warnings.\n    Object.keys(parameters).forEach((key) => {\n      this[key] = parameters[key];\n    });\n\n    // override default parameter values\n    this.setValues(parameters);\n\n    // override uniforms\n    this.uniforms = UniformsUtils.merge([uniforms, parameters.uniforms || {}]);\n\n    // set uniform values from parameters that affect uniforms\n    this.setUniformValues(parameters);\n  }\n\n  setUniformValues (values) {\n    if (!values) return;\n\n    const keys = Object.keys(values);\n\n    keys.forEach((key) => {\n      key in this.uniforms && (this.uniforms[key].value = values[key]);\n    });\n  }\n\n  stringifyChunk (name) {\n    let value;\n\n    if (!this[name]) {\n      value = '';\n    }\n    else if (typeof this[name] ===  'string') {\n      value = this[name];\n    }\n    else {\n      value = this[name].join('\\n');\n    }\n\n    return value;\n  }\n}\n\nclass BasicAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshBasicMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_basic/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['basic'].uniforms);\n\n    this.lights = false;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.basic.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.basic.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n  }\n}\n\nclass LambertAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshLambertMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_lambert/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   * @constructor\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['lambert'].uniforms);\n\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.lambert.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.lambert.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n  }\n}\n\nclass PhongAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshPhongMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_phong/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   * @constructor\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['phong'].uniforms);\n\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.phong.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.phong.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n      .replace(\n        '#include <lights_phong_fragment>',\n        `\n        #include <lights_phong_fragment>\n        ${this.stringifyChunk('fragmentSpecular')}\n        `\n      )\n  }\n}\n\nclass StandardAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshStandardMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_standard/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['physical'].uniforms);\n\n    this.lights = true;\n    this.extensions = (this.extensions || {});\n    this.extensions.derivatives = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.standard.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.standard.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n      .replace(\n        '#include <roughnessmap_fragment>',\n        `\n        float roughnessFactor = roughness;\n        ${this.stringifyChunk('fragmentRoughness')}\n        #ifdef USE_ROUGHNESSMAP\n\n        vec4 texelRoughness = texture2D( roughnessMap, vUv );\n          roughnessFactor *= texelRoughness.g;\n        #endif\n        `\n      )\n      .replace(\n        '#include <metalnessmap_fragment>',\n        `\n        float metalnessFactor = metalness;\n        ${this.stringifyChunk('fragmentMetalness')}\n\n        #ifdef USE_METALNESSMAP\n          vec4 texelMetalness = texture2D( metalnessMap, vUv );\n          metalnessFactor *= texelMetalness.b;\n        #endif\n        `\n      )\n  }\n}\n\nclass ToonAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshToonMaterial with custom shader chunks.\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['toon'].uniforms);\n\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.toon.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.toon.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n  }\n}\n\nclass PointsAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.PointsMaterial with custom shader chunks.\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   * @constructor\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['points'].uniforms);\n\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.points.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.points.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <premultiplied_alpha_fragment>',\n        `\n        ${this.stringifyChunk('fragmentShape')}\n\n        #include <premultiplied_alpha_fragment>\n        `\n      )\n  }\n}\n\nclass DepthAnimationMaterial extends BaseAnimationMaterial {\n  constructor (parameters) {\n    super(parameters, ShaderLib['depth'].uniforms);\n\n    this.depthPacking = RGBADepthPacking;\n    this.clipping = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = ShaderLib['depth'].fragmentShader;\n  }\n\n  concatVertexShader () {\n    return ShaderLib.depth.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n}\n\nclass DistanceAnimationMaterial extends BaseAnimationMaterial {\n  constructor (parameters) {\n    super(parameters, ShaderLib['distanceRGBA'].uniforms);\n\n    this.depthPacking = RGBADepthPacking;\n    this.clipping = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = ShaderLib['distanceRGBA'].fragmentShader;\n  }\n\n  concatVertexShader () {\n    return ShaderLib.distanceRGBA.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n}\n\nclass PrefabBufferGeometry extends BufferGeometry {\n  /**\n   * A BufferGeometry where a 'prefab' geometry is repeated a number of times.\n   *\n   * @param {Geometry|BufferGeometry} prefab The Geometry instance to repeat.\n   * @param {Number} count The number of times to repeat the geometry.\n   */\n  constructor (prefab, count) {\n    super();\n\n    /**\n     * A reference to the prefab geometry used to create this instance.\n     * @type {Geometry|BufferGeometry}\n     */\n    this.prefabGeometry = prefab;\n    this.isPrefabBufferGeometry = prefab.isBufferGeometry;\n\n    /**\n     * Number of prefabs.\n     * @type {Number}\n     */\n    this.prefabCount = count;\n\n    /**\n     * Number of vertices of the prefab.\n     * @type {Number}\n     */\n    if (this.isPrefabBufferGeometry) {\n      this.prefabVertexCount = prefab.attributes.position.count;\n    }\n    else {\n      this.prefabVertexCount = prefab.vertices.length;\n    }\n\n    this.bufferIndices();\n    this.bufferPositions();\n  }\n\n  bufferIndices () {\n    let prefabIndices = [];\n    let prefabIndexCount;\n\n    if (this.isPrefabBufferGeometry) {\n      if (this.prefabGeometry.index) {\n        prefabIndexCount = this.prefabGeometry.index.count;\n        prefabIndices = this.prefabGeometry.index.array;\n      }\n      else {\n        prefabIndexCount = this.prefabVertexCount;\n\n        for (let i = 0; i < prefabIndexCount; i++) {\n          prefabIndices.push(i);\n        }\n      }\n    }\n    else {\n      const prefabFaceCount = this.prefabGeometry.faces.length;\n      prefabIndexCount = prefabFaceCount * 3;\n\n      for (let i = 0; i < prefabFaceCount; i++) {\n        const face = this.prefabGeometry.faces[i];\n        prefabIndices.push(face.a, face.b, face.c);\n      }\n    }\n\n    const indexBuffer = new Uint32Array(this.prefabCount * prefabIndexCount);\n\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n\n    for (let i = 0; i < this.prefabCount; i++) {\n      for (let k = 0; k < prefabIndexCount; k++) {\n        indexBuffer[i * prefabIndexCount + k] = prefabIndices[k] + i * this.prefabVertexCount;\n      }\n    }\n  }\n\n  bufferPositions () {\n    const positionBuffer = this.createAttribute('position', 3).array;\n\n    if (this.isPrefabBufferGeometry) {\n      const positions = this.prefabGeometry.attributes.position.array;\n\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 3) {\n          positionBuffer[offset    ] = positions[j * 3];\n          positionBuffer[offset + 1] = positions[j * 3 + 1];\n          positionBuffer[offset + 2] = positions[j * 3 + 2];\n        }\n      }\n    }\n    else {\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 3) {\n          const prefabVertex = this.prefabGeometry.vertices[j];\n\n          positionBuffer[offset    ] = prefabVertex.x;\n          positionBuffer[offset + 1] = prefabVertex.y;\n          positionBuffer[offset + 2] = prefabVertex.z;\n        }\n      }\n    }\n  }\n\n  bufferUvs () {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n\n    if (this.isPrefabBufferGeometry) {\n      const uvs = this.prefabGeometry.attributes.uv.array;\n\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 2) {\n          uvBuffer[offset    ] = uvs[j * 2];\n          uvBuffer[offset + 1] = uvs[j * 2 + 1];\n        }\n      }\n    } else {\n      const prefabFaceCount = this.prefabGeometry.faces.length;\n      const uvs = [];\n\n      for (let i = 0; i < prefabFaceCount; i++) {\n        const face = this.prefabGeometry.faces[i];\n        const uv = this.prefabGeometry.faceVertexUvs[0][i];\n\n        uvs[face.a] = uv[0];\n        uvs[face.b] = uv[1];\n        uvs[face.c] = uv[2];\n      }\n\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 2) {\n          const uv = uvs[j];\n\n          uvBuffer[offset] = uv.x;\n          uvBuffer[offset + 1] = uv.y;\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates a BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each prefab upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPrefabData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.prefabCount * this.prefabVertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.prefabCount; i++) {\n        factory(data, i, this.prefabCount);\n        this.setPrefabData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  }\n\n  /**\n   * Sets data for all vertices of a prefab at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {Number} prefabIndex Index of the prefab in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setPrefabData (attribute, prefabIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = prefabIndex * this.prefabVertexCount * attribute.itemSize;\n\n    for (let i = 0; i < this.prefabVertexCount; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\n\nclass MultiPrefabBufferGeometry extends BufferGeometry {\n  /**\n   * A BufferGeometry where a 'prefab' geometry array is repeated a number of times.\n   *\n   * @param {Array} prefabs An array with Geometry instances to repeat.\n   * @param {Number} repeatCount The number of times to repeat the array of Geometries.\n   * @constructor\n   */\n  constructor (prefabs, repeatCount) {\n    super();\n\n    if (Array.isArray(prefabs)) {\n      this.prefabGeometries = prefabs;\n    } else {\n      this.prefabGeometries = [prefabs];\n    }\n\n    this.prefabGeometriesCount = this.prefabGeometries.length;\n\n    /**\n     * Number of prefabs.\n     * @type {Number}\n     */\n    this.prefabCount = repeatCount * this.prefabGeometriesCount;\n    /**\n     * How often the prefab array is repeated.\n     * @type {Number}\n     */\n    this.repeatCount = repeatCount;\n\n    /**\n     * Array of vertex counts per prefab.\n     * @type {Array}\n     */\n    this.prefabVertexCounts = this.prefabGeometries.map(p => p.isBufferGeometry ? p.attributes.position.count : p.vertices.length);\n    /**\n     * Total number of vertices for one repetition of the prefabs\n     * @type {number}\n     */\n    this.repeatVertexCount = this.prefabVertexCounts.reduce((r, v) => r + v, 0);\n\n    this.bufferIndices();\n    this.bufferPositions();\n  }\n\n  bufferIndices () {\n    let repeatIndexCount = 0;\n\n    this.prefabIndices = this.prefabGeometries.map(geometry => {\n      let indices = [];\n\n      if (geometry.isBufferGeometry) {\n        if (geometry.index) {\n          indices = geometry.index.array;\n        } else {\n          for (let i = 0; i < geometry.attributes.position.count; i++) {\n            indices.push(i);\n          }\n        }\n      } else {\n        for (let i = 0; i < geometry.faces.length; i++) {\n          const face = geometry.faces[i];\n          indices.push(face.a, face.b, face.c);\n        }\n      }\n\n      repeatIndexCount += indices.length;\n\n      return indices;\n    });\n\n    const indexBuffer = new Uint32Array(repeatIndexCount * this.repeatCount);\n    let indexOffset = 0;\n    let prefabOffset = 0;\n\n    for (let i = 0; i < this.prefabCount; i++) {\n      const index = i % this.prefabGeometriesCount;\n      const indices = this.prefabIndices[index];\n      const vertexCount = this.prefabVertexCounts[index];\n\n      for (let j = 0; j < indices.length; j++) {\n        indexBuffer[indexOffset++] = indices[j] + prefabOffset;\n      }\n\n      prefabOffset += vertexCount;\n    }\n\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n  }\n\n  bufferPositions () {\n    const positionBuffer = this.createAttribute('position', 3).array;\n\n    const prefabPositions = this.prefabGeometries.map((geometry, i) => {\n      let positions;\n\n      if (geometry.isBufferGeometry) {\n        positions = geometry.attributes.position.array;\n      } else {\n\n        const vertexCount = this.prefabVertexCounts[i];\n\n        positions = [];\n\n        for (let j = 0, offset = 0; j < vertexCount; j++) {\n          const prefabVertex = geometry.vertices[j];\n\n          positions[offset++] = prefabVertex.x;\n          positions[offset++] = prefabVertex.y;\n          positions[offset++] = prefabVertex.z;\n        }\n      }\n\n      return positions;\n    });\n\n    for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n      const index = i % this.prefabGeometries.length;\n      const vertexCount = this.prefabVertexCounts[index];\n      const positions = prefabPositions[index];\n\n      for (let j = 0; j < vertexCount; j++) {\n        positionBuffer[offset++] = positions[j * 3];\n        positionBuffer[offset++] = positions[j * 3 + 1];\n        positionBuffer[offset++] = positions[j * 3 + 2];\n      }\n    }\n  }\n\n  /**\n   * Creates a BufferAttribute with UV coordinates.\n   */\n  bufferUvs () {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n    const prefabUvs = this.prefabGeometries.map((geometry, i) => {\n      let uvs;\n\n      if (geometry.isBufferGeometry) {\n        if (!geometry.attributes.uv) {\n          console.error('No UV found in prefab geometry', geometry);\n        }\n\n        uvs = geometry.attributes.uv.array;\n      } else {\n        const prefabFaceCount = this.prefabIndices[i].length / 3;\n        const uvObjects = [];\n\n        for (let j = 0; j < prefabFaceCount; j++) {\n          const face = geometry.faces[j];\n          const uv = geometry.faceVertexUvs[0][j];\n\n          uvObjects[face.a] = uv[0];\n          uvObjects[face.b] = uv[1];\n          uvObjects[face.c] = uv[2];\n        }\n\n        uvs = [];\n\n        for (let k = 0; k < uvObjects.length; k++) {\n          uvs[k * 2] = uvObjects[k].x;\n          uvs[k * 2 + 1] = uvObjects[k].y;\n        }\n      }\n\n      return uvs;\n    });\n\n    for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n\n      const index = i % this.prefabGeometries.length;\n      const vertexCount = this.prefabVertexCounts[index];\n      const uvs = prefabUvs[index];\n\n      for (let j = 0; j < vertexCount; j++) {\n        uvBuffer[offset++] = uvs[j * 2];\n        uvBuffer[offset++] = uvs[j * 2 + 1];\n      }\n    }\n  }\n\n  /**\n   * Creates a BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each prefab upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPrefabData.\n   *\n   * @returns {BufferAttribute}\n   */\n   createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.repeatCount * this.repeatVertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.prefabCount; i++) {\n        factory(data, i, this.prefabCount);\n        this.setPrefabData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n   }\n\n   /**\n   * Sets data for all vertices of a prefab at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {Number} prefabIndex Index of the prefab in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setPrefabData (attribute, prefabIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    const prefabGeometryIndex = prefabIndex % this.prefabGeometriesCount;\n    const prefabGeometryVertexCount = this.prefabVertexCounts[prefabGeometryIndex];\n    const whole = (prefabIndex / this.prefabGeometriesCount | 0) * this.prefabGeometriesCount;\n    const wholeOffset = whole * this.repeatVertexCount;\n    const part = prefabIndex - whole;\n    let partOffset = 0;\n    let i = 0;\n\n    while(i < part) {\n      partOffset += this.prefabVertexCounts[i++];\n    }\n\n    let offset = (wholeOffset + partOffset) * attribute.itemSize;\n\n    for (let i = 0; i < prefabGeometryVertexCount; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\n\nclass InstancedPrefabBufferGeometry extends InstancedBufferGeometry {\n  /**\n   * A wrapper around THREE.InstancedBufferGeometry, which is more memory efficient than PrefabBufferGeometry, but requires the ANGLE_instanced_arrays extension.\n   *\n   * @param {BufferGeometry} prefab The Geometry instance to repeat.\n   * @param {Number} count The number of times to repeat the geometry.\n   */\n  constructor (prefab, count) {\n    super();\n\n    this.prefabGeometry = prefab;\n    this.copy(prefab);\n\n    this.instanceCount = count;\n    this.prefabCount = count;\n  }\n\n  /**\n   * Creates a BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each prefab upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPrefabData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.prefabCount * itemSize);\n    const attribute = new InstancedBufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.prefabCount; i++) {\n        factory(data, i, this.prefabCount);\n        this.setPrefabData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  };\n\n  /**\n   * Sets data for a prefab at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {Number} prefabIndex Index of the prefab in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setPrefabData (attribute, prefabIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = prefabIndex * attribute.itemSize;\n\n    for (let j = 0; j < attribute.itemSize; j++) {\n      attribute.array[offset++] = data[j];\n    }\n  };\n}\n\n/**\n * Collection of utility functions.\n * @namespace\n */\nconst Utils = {\n  /**\n   * Duplicates vertices so each face becomes separate.\n   * Same as THREE.ExplodeModifier.\n   *\n   * @param {THREE.Geometry} geometry Geometry instance to modify.\n   */\n  separateFaces: function (geometry) {\n    let vertices = [];\n\n    for (let i = 0, il = geometry.faces.length; i < il; i++) {\n      let n = vertices.length;\n      let face = geometry.faces[i];\n\n      let a = face.a;\n      let b = face.b;\n      let c = face.c;\n\n      let va = geometry.vertices[a];\n      let vb = geometry.vertices[b];\n      let vc = geometry.vertices[c];\n\n      vertices.push(va.clone());\n      vertices.push(vb.clone());\n      vertices.push(vc.clone());\n\n      face.a = n;\n      face.b = n + 1;\n      face.c = n + 2;\n    }\n\n    geometry.vertices = vertices;\n  },\n\n  /**\n   * Compute the centroid (center) of a THREE.Face3.\n   *\n   * @param {THREE.Geometry} geometry Geometry instance the face is in.\n   * @param {THREE.Face3} face Face object from the THREE.Geometry.faces array\n   * @param {THREE.Vector3=} v Optional vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  computeCentroid: function(geometry, face, v) {\n    let a = geometry.vertices[face.a];\n    let b = geometry.vertices[face.b];\n    let c = geometry.vertices[face.c];\n\n    v = v || new Vector3();\n\n    v.x = (a.x + b.x + c.x) / 3;\n    v.y = (a.y + b.y + c.y) / 3;\n    v.z = (a.z + b.z + c.z) / 3;\n\n    return v;\n  },\n\n  /**\n   * Get a random vector between box.min and box.max.\n   *\n   * @param {THREE.Box3} box THREE.Box3 instance.\n   * @param {THREE.Vector3=} v Optional vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  randomInBox: function(box, v) {\n    v = v || new Vector3();\n\n    v.x = Math$1.randFloat(box.min.x, box.max.x);\n    v.y = Math$1.randFloat(box.min.y, box.max.y);\n    v.z = Math$1.randFloat(box.min.z, box.max.z);\n\n    return v;\n  },\n\n  /**\n   * Get a random axis for quaternion rotation.\n   *\n   * @param {THREE.Vector3=} v Option vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  randomAxis: function(v) {\n    v = v || new Vector3();\n\n    v.x = Math$1.randFloatSpread(2.0);\n    v.y = Math$1.randFloatSpread(2.0);\n    v.z = Math$1.randFloatSpread(2.0);\n    v.normalize();\n\n    return v;\n  },\n\n  /**\n   * Create a THREE.BAS.DepthAnimationMaterial for shadows from a THREE.SpotLight or THREE.DirectionalLight by copying relevant shader chunks.\n   * Uniform values must be manually synced between the source material and the depth material.\n   *\n   * @see {@link http://three-bas-examples.surge.sh/examples/shadows/}\n   *\n   * @param {THREE.BAS.BaseAnimationMaterial} sourceMaterial Instance to get the shader chunks from.\n   * @returns {THREE.BAS.DepthAnimationMaterial}\n   */\n  createDepthAnimationMaterial: function(sourceMaterial) {\n    return new DepthAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  },\n\n  /**\n   * Create a THREE.BAS.DistanceAnimationMaterial for shadows from a THREE.PointLight by copying relevant shader chunks.\n   * Uniform values must be manually synced between the source material and the distance material.\n   *\n   * @see {@link http://three-bas-examples.surge.sh/examples/shadows/}\n   *\n   * @param {THREE.BAS.BaseAnimationMaterial} sourceMaterial Instance to get the shader chunks from.\n   * @returns {THREE.BAS.DistanceAnimationMaterial}\n   */\n  createDistanceAnimationMaterial: function(sourceMaterial) {\n    return new DistanceAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  }\n};\n\nclass ModelBufferGeometry extends BufferGeometry {\n  /**\n   * A THREE.BufferGeometry for animating individual faces of a THREE.Geometry.\n   *\n   * @param {THREE.Geometry} model The THREE.Geometry to base this geometry on.\n   * @param {Object=} options\n   * @param {Boolean=} options.computeCentroids If true, a centroids will be computed for each face and stored in THREE.BAS.ModelBufferGeometry.centroids.\n   * @param {Boolean=} options.localizeFaces If true, the positions for each face will be stored relative to the centroid. This is useful if you want to rotate or scale faces around their center.\n   */\n  constructor (model, options) {\n    super();\n\n    /**\n     * A reference to the geometry used to create this instance.\n     * @type {THREE.Geometry}\n     */\n    this.modelGeometry = model;\n\n    /**\n     * Number of faces of the model.\n     * @type {Number}\n     */\n    this.faceCount = this.modelGeometry.faces.length;\n\n    /**\n     * Number of vertices of the model.\n     * @type {Number}\n     */\n    this.vertexCount = this.modelGeometry.vertices.length;\n\n    options = options || {};\n    options.computeCentroids && this.computeCentroids();\n\n    this.bufferIndices();\n    this.bufferPositions(options.localizeFaces);\n  }\n\n  /**\n   * Computes a centroid for each face and stores it in THREE.BAS.ModelBufferGeometry.centroids.\n   */\n  computeCentroids () {\n    /**\n     * An array of centroids corresponding to the faces of the model.\n     *\n     * @type {Array}\n     */\n    this.centroids = [];\n\n    for (let i = 0; i < this.faceCount; i++) {\n      this.centroids[i] = Utils.computeCentroid(this.modelGeometry, this.modelGeometry.faces[i]);\n    }\n  }\n\n  bufferIndices () {\n    const indexBuffer = new Uint32Array(this.faceCount * 3);\n\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n\n    for (let i = 0, offset = 0; i < this.faceCount; i++, offset += 3) {\n      const face = this.modelGeometry.faces[i];\n\n      indexBuffer[offset    ] = face.a;\n      indexBuffer[offset + 1] = face.b;\n      indexBuffer[offset + 2] = face.c;\n    }\n  }\n\n  bufferPositions (localizeFaces) {\n    const positionBuffer = this.createAttribute('position', 3).array;\n    let i, offset;\n\n    if (localizeFaces === true) {\n      for (i = 0; i < this.faceCount; i++) {\n        const face = this.modelGeometry.faces[i];\n        const centroid = this.centroids ? this.centroids[i] : Utils.computeCentroid(this.modelGeometry, face);\n\n        const a = this.modelGeometry.vertices[face.a];\n        const b = this.modelGeometry.vertices[face.b];\n        const c = this.modelGeometry.vertices[face.c];\n\n        positionBuffer[face.a * 3]     = a.x - centroid.x;\n        positionBuffer[face.a * 3 + 1] = a.y - centroid.y;\n        positionBuffer[face.a * 3 + 2] = a.z - centroid.z;\n\n        positionBuffer[face.b * 3]     = b.x - centroid.x;\n        positionBuffer[face.b * 3 + 1] = b.y - centroid.y;\n        positionBuffer[face.b * 3 + 2] = b.z - centroid.z;\n\n        positionBuffer[face.c * 3]     = c.x - centroid.x;\n        positionBuffer[face.c * 3 + 1] = c.y - centroid.y;\n        positionBuffer[face.c * 3 + 2] = c.z - centroid.z;\n      }\n    }\n    else {\n      for (i = 0, offset = 0; i < this.vertexCount; i++, offset += 3) {\n        const vertex = this.modelGeometry.vertices[i];\n\n        positionBuffer[offset    ] = vertex.x;\n        positionBuffer[offset + 1] = vertex.y;\n        positionBuffer[offset + 2] = vertex.z;\n      }\n    }\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute with UV coordinates.\n   */\n  bufferUvs () {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n\n    for (let i = 0; i < this.faceCount; i++) {\n\n      const face = this.modelGeometry.faces[i];\n      let uv;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][0];\n      uvBuffer[face.a * 2]     = uv.x;\n      uvBuffer[face.a * 2 + 1] = uv.y;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][1];\n      uvBuffer[face.b * 2]     = uv.x;\n      uvBuffer[face.b * 2 + 1] = uv.y;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][2];\n      uvBuffer[face.c * 2]     = uv.x;\n      uvBuffer[face.c * 2 + 1] = uv.y;\n    }\n  }\n\n  /**\n   * Creates two THREE.BufferAttributes: skinIndex and skinWeight. Both are required for skinning.\n   */\n  bufferSkinning () {\n    const skinIndexBuffer = this.createAttribute('skinIndex', 4).array;\n    const skinWeightBuffer = this.createAttribute('skinWeight', 4).array;\n\n    for (let i = 0; i < this.vertexCount; i++) {\n      const skinIndex = this.modelGeometry.skinIndices[i];\n      const skinWeight = this.modelGeometry.skinWeights[i];\n\n      skinIndexBuffer[i * 4    ] = skinIndex.x;\n      skinIndexBuffer[i * 4 + 1] = skinIndex.y;\n      skinIndexBuffer[i * 4 + 2] = skinIndex.z;\n      skinIndexBuffer[i * 4 + 3] = skinIndex.w;\n\n      skinWeightBuffer[i * 4    ] = skinWeight.x;\n      skinWeightBuffer[i * 4 + 1] = skinWeight.y;\n      skinWeightBuffer[i * 4 + 2] = skinWeight.z;\n      skinWeightBuffer[i * 4 + 3] = skinWeight.w;\n    }\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {int} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each face upon creation. Accepts 3 arguments: data[], index and faceCount. Calls setFaceData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.vertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.faceCount; i++) {\n        factory(data, i, this.faceCount);\n        this.setFaceData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  }\n\n  /**\n   * Sets data for all vertices of a face at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|THREE.BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {int} faceIndex Index of the face in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setFaceData (attribute, faceIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = faceIndex * 3 * attribute.itemSize;\n\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\n\nclass PointBufferGeometry extends BufferGeometry {\n  /**\n   * A THREE.BufferGeometry consists of points.\n   * @param {Number} count The number of points.\n   * @constructor\n   */\n  constructor (count) {\n    super();\n\n    /**\n     * Number of points.\n     * @type {Number}\n     */\n    this.pointCount = count;\n\n    this.bufferPositions();\n  }\n\n  bufferPositions () {\n    this.createAttribute('position', 3);\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each point upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPointData.\n   *\n   * @returns {THREE.BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.pointCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n      for (let i = 0; i < this.pointCount; i++) {\n        factory(data, i, this.pointCount);\n        this.setPointData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  }\n\n  setPointData (attribute, pointIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = pointIndex * attribute.itemSize;\n\n    for (let j = 0; j < attribute.itemSize; j++) {\n      attribute.array[offset++] = data[j];\n    }\n  }\n}\n\nvar catmull_rom_spline = \"vec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, vec2 c) {\\n    vec4 v0 = (p2 - p0) * c.x;\\n    vec4 v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nvec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t, vec2 c) {\\n    vec3 v0 = (p2 - p0) * c.x;\\n    vec3 v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t, vec2 c) {\\n    vec2 v0 = (p2 - p0) * c.x;\\n    vec2 v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return vec2((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t, vec2 c) {\\n    float v0 = (p2 - p0) * c.x;\\n    float v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return float((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nivec4 getCatmullRomSplineIndices(float l, float p) {\\n    float index = floor(p);\\n    int i0 = int(max(0.0, index - 1.0));\\n    int i1 = int(index);\\n    int i2 = int(min(index + 1.0, l));\\n    int i3 = int(min(index + 2.0, l));\\n    return ivec4(i0, i1, i2, i3);\\n}\\nivec4 getCatmullRomSplineIndicesClosed(float l, float p) {\\n    float index = floor(p);\\n    int i0 = int(index == 0.0 ? l : index - 1.0);\\n    int i1 = int(index);\\n    int i2 = int(mod(index + 1.0, l));\\n    int i3 = int(mod(index + 2.0, l));\\n    return ivec4(i0, i1, i2, i3);\\n}\\n\";\n\nvar cubic_bezier = \"vec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\\n}\\nvec2 cubicBezier(vec2 p0, vec2 c0, vec2 c1, vec2 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\\n}\\n\";\n\nvar ease_back_in = \"float easeBackIn(float p, float amplitude) {\\n    return p * p * ((amplitude + 1.0) * p - amplitude);\\n}\\nfloat easeBackIn(float p) {\\n    return easeBackIn(p, 1.70158);\\n}\\nfloat easeBackIn(float t, float b, float c, float d, float amplitude) {\\n    return b + easeBackIn(t / d, amplitude) * c;\\n}\\nfloat easeBackIn(float t, float b, float c, float d) {\\n    return b + easeBackIn(t / d) * c;\\n}\\n\";\n\nvar ease_back_in_out = \"float easeBackInOut(float p, float amplitude) {\\n    amplitude *= 1.525;\\n    return ((p *= 2.0) < 1.0) ? 0.5 * p * p * ((amplitude + 1.0) * p - amplitude) : 0.5 * ((p -= 2.0) * p * ((amplitude + 1.0) * p + amplitude) + 2.0);\\n}\\nfloat easeBackInOut(float p) {\\n    return easeBackInOut(p, 1.70158);\\n}\\nfloat easeBackInOut(float t, float b, float c, float d, float amplitude) {\\n    return b + easeBackInOut(t / d, amplitude) * c;\\n}\\nfloat easeBackInOut(float t, float b, float c, float d) {\\n    return b + easeBackInOut(t / d) * c;\\n}\\n\";\n\nvar ease_back_out = \"float easeBackOut(float p, float amplitude) {\\n    return ((p = p - 1.0) * p * ((amplitude + 1.0) * p + amplitude) + 1.0);\\n}\\nfloat easeBackOut(float p) {\\n    return easeBackOut(p, 1.70158);\\n}\\nfloat easeBackOut(float t, float b, float c, float d, float amplitude) {\\n    return b + easeBackOut(t / d, amplitude) * c;\\n}\\nfloat easeBackOut(float t, float b, float c, float d) {\\n    return b + easeBackOut(t / d) * c;\\n}\\n\";\n\nvar ease_bezier = \"float easeBezier(float p, vec4 curve) {\\n    float ip = 1.0 - p;\\n    return (3.0 * ip * ip * p * curve.xy + 3.0 * ip * p * p * curve.zw + p * p * p).y;\\n}\\nfloat easeBezier(float t, float b, float c, float d, vec4 curve) {\\n    return b + easeBezier(t / d, curve) * c;\\n}\\n\";\n\nvar ease_bounce_in = \"float easeBounceIn(float p) {\\n    if ((p = 1.0 - p) < 1.0 / 2.75) {\\n        return 1.0 - (7.5625 * p * p);\\n    } else if (p < 2.0 / 2.75) {\\n        return 1.0 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);\\n    } else if (p < 2.5 / 2.75) {\\n        return 1.0 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);\\n    }\\n    return 1.0 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);\\n}\\nfloat easeBounceIn(float t, float b, float c, float d) {\\n    return b + easeBounceIn(t / d) * c;\\n}\\n\";\n\nvar ease_bounce_in_out = \"float easeBounceInOut(float p) {\\n    bool invert = (p < 0.5);\\n    p = invert ? (1.0 - (p * 2.0)) : ((p * 2.0) - 1.0);\\n    if (p < 1.0 / 2.75) {\\n        p = 7.5625 * p * p;\\n    } else if (p < 2.0 / 2.75) {\\n        p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\\n    } else if (p < 2.5 / 2.75) {\\n        p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\\n    } else {\\n        p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\\n    }\\n    return invert ? (1.0 - p) * 0.5 : p * 0.5 + 0.5;\\n}\\nfloat easeBounceInOut(float t, float b, float c, float d) {\\n    return b + easeBounceInOut(t / d) * c;\\n}\\n\";\n\nvar ease_bounce_out = \"float easeBounceOut(float p) {\\n    if (p < 1.0 / 2.75) {\\n        return 7.5625 * p * p;\\n    } else if (p < 2.0 / 2.75) {\\n        return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\\n    } else if (p < 2.5 / 2.75) {\\n        return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\\n    }\\n    return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\\n}\\nfloat easeBounceOut(float t, float b, float c, float d) {\\n    return b + easeBounceOut(t / d) * c;\\n}\\n\";\n\nvar ease_circ_in = \"float easeCircIn(float p) {\\n    return -(sqrt(1.0 - p * p) - 1.0);\\n}\\nfloat easeCircIn(float t, float b, float c, float d) {\\n    return b + easeCircIn(t / d) * c;\\n}\\n\";\n\nvar ease_circ_in_out = \"float easeCircInOut(float p) {\\n    return ((p *= 2.0) < 1.0) ? -0.5 * (sqrt(1.0 - p * p) - 1.0) : 0.5 * (sqrt(1.0 - (p -= 2.0) * p) + 1.0);\\n}\\nfloat easeCircInOut(float t, float b, float c, float d) {\\n    return b + easeCircInOut(t / d) * c;\\n}\\n\";\n\nvar ease_circ_out = \"float easeCircOut(float p) {\\n  return sqrt(1.0 - (p = p - 1.0) * p);\\n}\\nfloat easeCircOut(float t, float b, float c, float d) {\\n  return b + easeCircOut(t / d) * c;\\n}\\n\";\n\nvar ease_cubic_in = \"float easeCubicIn(float t) {\\n  return t * t * t;\\n}\\nfloat easeCubicIn(float t, float b, float c, float d) {\\n  return b + easeCubicIn(t / d) * c;\\n}\\n\";\n\nvar ease_cubic_in_out = \"float easeCubicInOut(float t) {\\n  return (t /= 0.5) < 1.0 ? 0.5 * t * t * t : 0.5 * ((t-=2.0) * t * t + 2.0);\\n}\\nfloat easeCubicInOut(float t, float b, float c, float d) {\\n  return b + easeCubicInOut(t / d) * c;\\n}\\n\";\n\nvar ease_cubic_out = \"float easeCubicOut(float t) {\\n  float f = t - 1.0;\\n  return f * f * f + 1.0;\\n}\\nfloat easeCubicOut(float t, float b, float c, float d) {\\n  return b + easeCubicOut(t / d) * c;\\n}\\n\";\n\nvar ease_elastic_in = \"float easeElasticIn(float p, float amplitude, float period) {\\n    float p1 = max(amplitude, 1.0);\\n    float p2 = period / min(amplitude, 1.0);\\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\\n    return -(p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2));\\n}\\nfloat easeElasticIn(float p) {\\n    return easeElasticIn(p, 1.0, 0.3);\\n}\\nfloat easeElasticIn(float t, float b, float c, float d, float amplitude, float period) {\\n    return b + easeElasticIn(t / d, amplitude, period) * c;\\n}\\nfloat easeElasticIn(float t, float b, float c, float d) {\\n    return b + easeElasticIn(t / d) * c;\\n}\\n\";\n\nvar ease_elastic_in_out = \"float easeElasticInOut(float p, float amplitude, float period) {\\n    float p1 = max(amplitude, 1.0);\\n    float p2 = period / min(amplitude, 1.0);\\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\\n    return ((p *= 2.0) < 1.0) ? -0.5 * (p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2)) : p1 * pow(2.0, -10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2) * 0.5 + 1.0;\\n}\\nfloat easeElasticInOut(float p) {\\n    return easeElasticInOut(p, 1.0, 0.3);\\n}\\nfloat easeElasticInOut(float t, float b, float c, float d, float amplitude, float period) {\\n    return b + easeElasticInOut(t / d, amplitude, period) * c;\\n}\\nfloat easeElasticInOut(float t, float b, float c, float d) {\\n    return b + easeElasticInOut(t / d) * c;\\n}\\n\";\n\nvar ease_elastic_out = \"float easeElasticOut(float p, float amplitude, float period) {\\n    float p1 = max(amplitude, 1.0);\\n    float p2 = period / min(amplitude, 1.0);\\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\\n    return p1 * pow(2.0, -10.0 * p) * sin((p - p3) * PI2 / p2) + 1.0;\\n}\\nfloat easeElasticOut(float p) {\\n    return easeElasticOut(p, 1.0, 0.3);\\n}\\nfloat easeElasticOut(float t, float b, float c, float d, float amplitude, float period) {\\n    return b + easeElasticOut(t / d, amplitude, period) * c;\\n}\\nfloat easeElasticOut(float t, float b, float c, float d) {\\n    return b + easeElasticOut(t / d) * c;\\n}\\n\";\n\nvar ease_expo_in = \"float easeExpoIn(float p) {\\n    return pow(2.0, 10.0 * (p - 1.0));\\n}\\nfloat easeExpoIn(float t, float b, float c, float d) {\\n    return b + easeExpoIn(t / d) * c;\\n}\\n\";\n\nvar ease_expo_in_out = \"float easeExpoInOut(float p) {\\n    return ((p *= 2.0) < 1.0) ? 0.5 * pow(2.0, 10.0 * (p - 1.0)) : 0.5 * (2.0 - pow(2.0, -10.0 * (p - 1.0)));\\n}\\nfloat easeExpoInOut(float t, float b, float c, float d) {\\n    return b + easeExpoInOut(t / d) * c;\\n}\\n\";\n\nvar ease_expo_out = \"float easeExpoOut(float p) {\\n  return 1.0 - pow(2.0, -10.0 * p);\\n}\\nfloat easeExpoOut(float t, float b, float c, float d) {\\n  return b + easeExpoOut(t / d) * c;\\n}\\n\";\n\nvar ease_quad_in = \"float easeQuadIn(float t) {\\n    return t * t;\\n}\\nfloat easeQuadIn(float t, float b, float c, float d) {\\n  return b + easeQuadIn(t / d) * c;\\n}\\n\";\n\nvar ease_quad_in_out = \"float easeQuadInOut(float t) {\\n    float p = 2.0 * t * t;\\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\\n}\\nfloat easeQuadInOut(float t, float b, float c, float d) {\\n    return b + easeQuadInOut(t / d) * c;\\n}\\n\";\n\nvar ease_quad_out = \"float easeQuadOut(float t) {\\n  return -t * (t - 2.0);\\n}\\nfloat easeQuadOut(float t, float b, float c, float d) {\\n  return b + easeQuadOut(t / d) * c;\\n}\\n\";\n\nvar ease_quart_in = \"float easeQuartIn(float t) {\\n  return t * t * t * t;\\n}\\nfloat easeQuartIn(float t, float b, float c, float d) {\\n  return b + easeQuartIn(t / d) * c;\\n}\\n\";\n\nvar ease_quart_in_out = \"float easeQuartInOut(float t) {\\n    return t < 0.5 ? 8.0 * pow(t, 4.0) : -8.0 * pow(t - 1.0, 4.0) + 1.0;\\n}\\nfloat easeQuartInOut(float t, float b, float c, float d) {\\n    return b + easeQuartInOut(t / d) * c;\\n}\\n\";\n\nvar ease_quart_out = \"float easeQuartOut(float t) {\\n  return 1.0 - pow(1.0 - t, 4.0);\\n}\\nfloat easeQuartOut(float t, float b, float c, float d) {\\n  return b + easeQuartOut(t / d) * c;\\n}\\n\";\n\nvar ease_quint_in = \"float easeQuintIn(float t) {\\n    return pow(t, 5.0);\\n}\\nfloat easeQuintIn(float t, float b, float c, float d) {\\n    return b + easeQuintIn(t / d) * c;\\n}\\n\";\n\nvar ease_quint_in_out = \"float easeQuintInOut(float t) {\\n    return (t /= 0.5) < 1.0 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2.0) * t * t * t * t + 2.0);\\n}\\nfloat easeQuintInOut(float t, float b, float c, float d) {\\n    return b + easeQuintInOut(t / d) * c;\\n}\\n\";\n\nvar ease_quint_out = \"float easeQuintOut(float t) {\\n    return (t -= 1.0) * t * t * t * t + 1.0;\\n}\\nfloat easeQuintOut(float t, float b, float c, float d) {\\n    return b + easeQuintOut(t / d) * c;\\n}\\n\";\n\nvar ease_sine_in = \"float easeSineIn(float p) {\\n  return -cos(p * 1.57079632679) + 1.0;\\n}\\nfloat easeSineIn(float t, float b, float c, float d) {\\n  return b + easeSineIn(t / d) * c;\\n}\\n\";\n\nvar ease_sine_in_out = \"float easeSineInOut(float p) {\\n  return -0.5 * (cos(PI * p) - 1.0);\\n}\\nfloat easeSineInOut(float t, float b, float c, float d) {\\n  return b + easeSineInOut(t / d) * c;\\n}\\n\";\n\nvar ease_sine_out = \"float easeSineOut(float p) {\\n  return sin(p * 1.57079632679);\\n}\\nfloat easeSineOut(float t, float b, float c, float d) {\\n  return b + easeSineOut(t / d) * c;\\n}\\n\";\n\nvar quadratic_bezier = \"vec3 quadraticBezier(vec3 p0, vec3 c0, vec3 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\\n}\\nvec2 quadraticBezier(vec2 p0, vec2 c0, vec2 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\\n}\";\n\nvar quaternion_rotation = \"vec3 rotateVector(vec4 q, vec3 v) {\\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\\n}\\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\\n    float halfAngle = angle * 0.5;\\n    return vec4(axis.xyz * sin(halfAngle), cos(halfAngle));\\n}\\n\";\n\nvar quaternion_slerp = \"vec4 quatSlerp(vec4 q0, vec4 q1, float t) {\\n    float s = 1.0 - t;\\n    float c = dot(q0, q1);\\n    float dir = -1.0;    float sqrSn = 1.0 - c * c;\\n    if (sqrSn > 2.220446049250313e-16) {\\n        float sn = sqrt(sqrSn);\\n        float len = atan(sn, c * dir);\\n        s = sin(s * len) / sn;\\n        t = sin(t * len) / sn;\\n    }\\n    float tDir = t * dir;\\n    return normalize(q0 * s + q1 * tDir);\\n}\\n\";\n\n// generated by scripts/build_shader_chunks.js\n\n\nconst ShaderChunk = {\n  catmull_rom_spline: catmull_rom_spline,\n  cubic_bezier: cubic_bezier,\n  ease_back_in: ease_back_in,\n  ease_back_in_out: ease_back_in_out,\n  ease_back_out: ease_back_out,\n  ease_bezier: ease_bezier,\n  ease_bounce_in: ease_bounce_in,\n  ease_bounce_in_out: ease_bounce_in_out,\n  ease_bounce_out: ease_bounce_out,\n  ease_circ_in: ease_circ_in,\n  ease_circ_in_out: ease_circ_in_out,\n  ease_circ_out: ease_circ_out,\n  ease_cubic_in: ease_cubic_in,\n  ease_cubic_in_out: ease_cubic_in_out,\n  ease_cubic_out: ease_cubic_out,\n  ease_elastic_in: ease_elastic_in,\n  ease_elastic_in_out: ease_elastic_in_out,\n  ease_elastic_out: ease_elastic_out,\n  ease_expo_in: ease_expo_in,\n  ease_expo_in_out: ease_expo_in_out,\n  ease_expo_out: ease_expo_out,\n  ease_quad_in: ease_quad_in,\n  ease_quad_in_out: ease_quad_in_out,\n  ease_quad_out: ease_quad_out,\n  ease_quart_in: ease_quart_in,\n  ease_quart_in_out: ease_quart_in_out,\n  ease_quart_out: ease_quart_out,\n  ease_quint_in: ease_quint_in,\n  ease_quint_in_out: ease_quint_in_out,\n  ease_quint_out: ease_quint_out,\n  ease_sine_in: ease_sine_in,\n  ease_sine_in_out: ease_sine_in_out,\n  ease_sine_out: ease_sine_out,\n  quadratic_bezier: quadratic_bezier,\n  quaternion_rotation: quaternion_rotation,\n  quaternion_slerp: quaternion_slerp,\n\n};\n\n/**\n * A timeline transition segment. An instance of this class is created internally when calling {@link THREE.BAS.Timeline.add}, so you should not use this class directly.\n * The instance is also passed the the compiler function if you register a transition through {@link THREE.BAS.Timeline.register}. There you can use the public properties of the segment to compile the glsl string.\n * @param {string} key A string key generated by the timeline to which this segment belongs. Keys are unique.\n * @param {number} start Start time of this segment in a timeline in seconds.\n * @param {number} duration Duration of this segment in seconds.\n * @param {object} transition Object describing the transition.\n * @param {function} compiler A reference to the compiler function from a transition definition.\n * @constructor\n */\nfunction TimelineSegment(key, start, duration, transition, compiler) {\n  this.key = key;\n  this.start = start;\n  this.duration = duration;\n  this.transition = transition;\n  this.compiler = compiler;\n\n  this.trail = 0;\n}\n\nTimelineSegment.prototype.compile = function() {\n  return this.compiler(this);\n};\n\nObject.defineProperty(TimelineSegment.prototype, 'end', {\n  get: function() {\n    return this.start + this.duration;\n  }\n});\n\n/**\n * A utility class to create an animation timeline which can be baked into a (vertex) shader.\n * By default the timeline supports translation, scale and rotation. This can be extended or overridden.\n * @constructor\n */\nfunction Timeline() {\n  /**\n   * The total duration of the timeline in seconds.\n   * @type {number}\n   */\n  this.duration = 0;\n\n  /**\n   * The name of the value that segments will use to read the time. Defaults to 'tTime'.\n   * @type {string}\n   */\n  this.timeKey = 'tTime';\n\n  this.segments = {};\n  this.__key = 0;\n}\n\n// static definitions map\nTimeline.segmentDefinitions = {};\n\n/**\n * Registers a transition definition for use with {@link THREE.BAS.Timeline.add}.\n * @param {String} key Name of the transition. Defaults include 'scale', 'rotate' and 'translate'.\n * @param {Object} definition\n * @param {Function} definition.compiler A function that generates a glsl string for a transition segment. Accepts a THREE.BAS.TimelineSegment as the sole argument.\n * @param {*} definition.defaultFrom The initial value for a transform.from. For example, the defaultFrom for a translation is THREE.Vector3(0, 0, 0).\n * @static\n */\nTimeline.register = function(key, definition) {\n  Timeline.segmentDefinitions[key] = definition;\n  \n  return definition;\n};\n\n/**\n * Add a transition to the timeline.\n * @param {number} duration Duration in seconds\n * @param {object} transitions An object containing one or several transitions. The keys should match transform definitions.\n * The transition object for each key will be passed to the matching definition's compiler. It can have arbitrary properties, but the Timeline expects at least a 'to', 'from' and an optional 'ease'.\n * @param {number|string} [positionOffset] Position in the timeline. Defaults to the end of the timeline. If a number is provided, the transition will be inserted at that time in seconds. Strings ('+=x' or '-=x') can be used for a value relative to the end of timeline.\n */\nTimeline.prototype.add = function(duration, transitions, positionOffset) {\n  // stop rollup from complaining about eval\n  const _eval = eval;\n  \n  let start = this.duration;\n\n  if (positionOffset !== undefined) {\n    if (typeof positionOffset === 'number') {\n      start = positionOffset;\n    }\n    else if (typeof positionOffset === 'string') {\n      _eval('start' + positionOffset);\n    }\n\n    this.duration = Math.max(this.duration, start + duration);\n  }\n  else {\n    this.duration += duration;\n  }\n\n  let keys = Object.keys(transitions), key;\n\n  for (let i = 0; i < keys.length; i++) {\n    key = keys[i];\n\n    this.processTransition(key, transitions[key], start, duration);\n  }\n};\n\nTimeline.prototype.processTransition = function(key, transition, start, duration) {\n  const definition = Timeline.segmentDefinitions[key];\n\n  let segments = this.segments[key];\n  if (!segments) segments = this.segments[key] = [];\n\n  if (transition.from === undefined) {\n    if (segments.length === 0) {\n      transition.from = definition.defaultFrom;\n    }\n    else {\n      transition.from = segments[segments.length - 1].transition.to;\n    }\n  }\n\n  segments.push(new TimelineSegment((this.__key++).toString(), start, duration, transition, definition.compiler));\n};\n\n/**\n * Compiles the timeline into a glsl string array that can be injected into a (vertex) shader.\n * @returns {Array}\n */\nTimeline.prototype.compile = function() {\n  const c = [];\n\n  const keys = Object.keys(this.segments);\n  let segments;\n\n  for (let i = 0; i < keys.length; i++) {\n    segments = this.segments[keys[i]];\n\n    this.fillGaps(segments);\n\n    segments.forEach(function(s) {\n      c.push(s.compile());\n    });\n  }\n\n  return c;\n};\nTimeline.prototype.fillGaps = function(segments) {\n  if (segments.length === 0) return;\n\n  let s0, s1;\n\n  for (let i = 0; i < segments.length - 1; i++) {\n    s0 = segments[i];\n    s1 = segments[i + 1];\n\n    s0.trail = s1.start - s0.end;\n  }\n\n  // pad last segment until end of timeline\n  s0 = segments[segments.length - 1];\n  s0.trail = this.duration - s0.end;\n};\n\n/**\n * Get a compiled glsl string with calls to transform functions for a given key.\n * The order in which these transitions are applied matters because they all operate on the same value.\n * @param {string} key A key matching a transform definition.\n * @returns {string}\n */\nTimeline.prototype.getTransformCalls = function(key) {\n  let t = this.timeKey;\n\n  return this.segments[key] ?  this.segments[key].map(function(s) {\n    return `applyTransform${s.key}(${t}, transformed);`;\n  }).join('\\n') : '';\n};\n\nconst TimelineChunks = {\n  vec3: function(n, v, p) {\n    const x = (v.x || 0).toPrecision(p);\n    const y = (v.y || 0).toPrecision(p);\n    const z = (v.z || 0).toPrecision(p);\n\n    return `vec3 ${n} = vec3(${x}, ${y}, ${z});`;\n  },\n  vec4: function(n, v, p) {\n    const x = (v.x || 0).toPrecision(p);\n    const y = (v.y || 0).toPrecision(p);\n    const z = (v.z || 0).toPrecision(p);\n    const w = (v.w || 0).toPrecision(p);\n  \n    return `vec4 ${n} = vec4(${x}, ${y}, ${z}, ${w});`;\n  },\n  delayDuration: function(segment) {\n    return `\n    float cDelay${segment.key} = ${segment.start.toPrecision(4)};\n    float cDuration${segment.key} = ${segment.duration.toPrecision(4)};\n    `;\n  },\n  progress: function(segment) {\n    // zero duration segments should always render complete\n    if (segment.duration === 0) {\n      return `float progress = 1.0;`\n    }\n    else {\n      return `\n      float progress = clamp(time - cDelay${segment.key}, 0.0, cDuration${segment.key}) / cDuration${segment.key};\n      ${segment.transition.ease ? `progress = ${segment.transition.ease}(progress${(segment.transition.easeParams ? `, ${segment.transition.easeParams.map((v) => v.toPrecision(4)).join(`, `)}` : ``)});` : ``}\n      `;\n    }\n  },\n  renderCheck: function(segment) {\n    const startTime = segment.start.toPrecision(4);\n    const endTime = (segment.end + segment.trail).toPrecision(4);\n\n    return `if (time < ${startTime} || time > ${endTime}) return;`;\n  }\n};\n\nconst TranslationSegment = {\n  compiler: function(segment) {\n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec3(`cTranslateFrom${segment.key}`, segment.transition.from, 2)}\n    ${TimelineChunks.vec3(`cTranslateTo${segment.key}`, segment.transition.to, 2)}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n    \n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n    \n      v += mix(cTranslateFrom${segment.key}, cTranslateTo${segment.key}, progress);\n    }\n    `;\n  },\n  defaultFrom: new Vector3(0, 0, 0)\n};\n\nTimeline.register('translate', TranslationSegment);\n\nconst ScaleSegment = {\n  compiler: function(segment) {\n    const origin = segment.transition.origin;\n    \n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec3(`cScaleFrom${segment.key}`, segment.transition.from, 2)}\n    ${TimelineChunks.vec3(`cScaleTo${segment.key}`, segment.transition.to, 2)}\n    ${origin ? TimelineChunks.vec3(`cOrigin${segment.key}`, origin, 2) : ''}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n    \n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n    \n      ${origin ? `v -= cOrigin${segment.key};` : ''}\n      v *= mix(cScaleFrom${segment.key}, cScaleTo${segment.key}, progress);\n      ${origin ? `v += cOrigin${segment.key};` : ''}\n    }\n    `;\n  },\n  defaultFrom: new Vector3(1, 1, 1)\n};\n\nTimeline.register('scale', ScaleSegment);\n\nconst RotationSegment = {\n  compiler(segment) {\n    const fromAxisAngle = new Vector4(\n      segment.transition.from.axis.x,\n      segment.transition.from.axis.y,\n      segment.transition.from.axis.z,\n      segment.transition.from.angle\n    );\n  \n    const toAxis = segment.transition.to.axis || segment.transition.from.axis;\n    const toAxisAngle = new Vector4(\n      toAxis.x,\n      toAxis.y,\n      toAxis.z,\n      segment.transition.to.angle\n    );\n  \n    const origin = segment.transition.origin;\n    \n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec4(`cRotationFrom${segment.key}`, fromAxisAngle, 8)}\n    ${TimelineChunks.vec4(`cRotationTo${segment.key}`, toAxisAngle, 8)}\n    ${origin ? TimelineChunks.vec3(`cOrigin${segment.key}`, origin, 2) : ''}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n\n      ${origin ? `v -= cOrigin${segment.key};` : ''}\n      vec3 axis = normalize(mix(cRotationFrom${segment.key}.xyz, cRotationTo${segment.key}.xyz, progress));\n      float angle = mix(cRotationFrom${segment.key}.w, cRotationTo${segment.key}.w, progress);\n      vec4 q = quatFromAxisAngle(axis, angle);\n      v = rotateVector(q, v);\n      ${origin ? `v += cOrigin${segment.key};` : ''}\n    }\n    `;\n  },\n  defaultFrom: {axis: new Vector3(), angle: 0}\n};\n\nTimeline.register('rotate', RotationSegment);\n\nexport { BaseAnimationMaterial, BasicAnimationMaterial, DepthAnimationMaterial, DistanceAnimationMaterial, InstancedPrefabBufferGeometry, LambertAnimationMaterial, ModelBufferGeometry, MultiPrefabBufferGeometry, PhongAnimationMaterial, PointBufferGeometry, PointsAnimationMaterial, PrefabBufferGeometry, RotationSegment, ScaleSegment, ShaderChunk, StandardAnimationMaterial, Timeline, TimelineChunks, TimelineSegment, ToonAnimationMaterial, TranslationSegment, Utils };\n"],"sourceRoot":""}