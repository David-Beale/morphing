{"version":3,"sources":["Assets/jet.glb","Assets/coke.glb","Assets/cone.glb","Assets/dino.glb","Assets/dog.glb","Assets/flower.glb","Assets/grogu.glb","Assets/helmet.glb","Assets/pc.glb","Assets/reptile.glb","Assets/tie.glb","Components/fillWithPoints/extractVertices/getNewPoint/getNewPoint.js","Components/fillWithPoints/subdivideFaces/checkFace/checkFace.js","Components/fillWithPoints/subdivideFaces/subdivideOneFace/getMidPoint/getMidPoint.js","Components/useModels.js","Components/useData.js","Components/Test.js","Components/useBufferAnimation.js"],"names":["Vector3","Euler","Triangle","Line3","useGLTF","preload","jet","dino","grogu","reptile","flower","cone","tie","dog","helmet","pc","coke","models","map","model","data","colors","forEach","point","colorIndex","CONFIG","duration","totalDelay","Test","nextModel","animating","useRef","meshRef","i","useState","setdata","prevData","useEffect","current","length","prev","useData","useMemo","colorArray","maxLength","prefab","THREE","geometry","InstancedPrefabBufferGeometry","startPositionBuffer","createAttribute","endPositionBuffer","startTimeBuffer","startColorBuffer","endColorBuffer","tmpa","counter","prevDataPoint","setPrefabData","uniforms","time","value","material","StandardAnimationMaterial","roughness","metalness","vertexColors","vertexParameters","vertexFunctions","ShaderChunk","vertexPosition","vertexColor","useBufferAnimation","geo","mat","useFrame","frustumCulled","ref"],"mappings":"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","file":"static/js/3.1efe34d7.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/jet.a5dd25aa.glb\";","export default __webpack_public_path__ + \"static/media/coke.5ce0700f.glb\";","export default __webpack_public_path__ + \"static/media/cone.d99113c4.glb\";","export default __webpack_public_path__ + \"static/media/dino.fdeaa623.glb\";","export default __webpack_public_path__ + \"static/media/dog.dc02d258.glb\";","export default __webpack_public_path__ + \"static/media/flower.0cd08953.glb\";","export default __webpack_public_path__ + \"static/media/grogu.bb7840e1.glb\";","export default __webpack_public_path__ + \"static/media/helmet.e1611e1a.glb\";","export default __webpack_public_path__ + \"static/media/pc.48dbf2bf.glb\";","export default __webpack_public_path__ + \"static/media/reptile.3f2d6967.glb\";","export default __webpack_public_path__ + \"static/media/tie.82df7b2b.glb\";","import { Vector3, Euler } from \"three\";\r\n\r\nconst targetSize = 405;\r\nconst offset = new Vector3(0, -1, 0);\r\nconst rot = new Euler(0, -0, 0.7);\r\n\r\nexport default function getNewPoint(geometry, i, size) {\r\n  const x = geometry.attributes.position.array[i * 3 + 0];\r\n  const y = geometry.attributes.position.array[i * 3 + 1];\r\n  const z = geometry.attributes.position.array[i * 3 + 2];\r\n\r\n  const newPoint = new Vector3(x, y, z);\r\n\r\n  // newPoint.applyEuler(rot);\r\n  // newPoint.add(offset);\r\n  if (geometry.position) {\r\n    newPoint.add(geometry.position);\r\n  }\r\n  if (geometry.scale) {\r\n    newPoint.multiply(geometry.scale);\r\n  }\r\n  if (geometry.rotation) {\r\n    newPoint.applyEuler(geometry.rotation);\r\n  }\r\n  newPoint.multiplyScalar(targetSize / size);\r\n  newPoint.x = Math.round(newPoint.x);\r\n  newPoint.y = Math.round(newPoint.y);\r\n  newPoint.z = Math.round(newPoint.z);\r\n\r\n  newPoint.u = geometry.attributes.uv?.array[i * 2];\r\n  newPoint.v = geometry.attributes.uv?.array[i * 2 + 1];\r\n  return newPoint;\r\n}\r\n","import { Triangle } from \"three\";\r\n\r\nconst triangle = new Triangle();\r\nconst minDist = 10;\r\nconst minArea = 1;\r\n\r\nexport default function checkFace(face, areaCheck = true) {\r\n  if (areaCheck) {\r\n    //based on area\r\n    triangle.set(face[0], face[1], face[2]);\r\n    const area = triangle.getArea();\r\n    return area > minArea;\r\n  } else {\r\n    //based on minimum line distance\r\n    return (\r\n      face[0].distanceToSquared(face[1]) > minDist ||\r\n      face[1].distanceToSquared(face[2]) > minDist ||\r\n      face[2].distanceToSquared(face[0]) > minDist\r\n    );\r\n  }\r\n}\r\n","import { Line3, Vector3 } from \"three\";\r\n\r\nconst line = new Line3();\r\n\r\nexport default function getMidPoint(point1, point2) {\r\n  line.start = point1;\r\n  line.end = point2;\r\n  const result = new Vector3();\r\n  line.getCenter(result);\r\n  result.x = Math.round(result.x);\r\n  result.y = Math.round(result.y);\r\n  result.z = Math.round(result.z);\r\n\r\n  if (point1.u) {\r\n    result.u = (point1.u + point2.u) / 2;\r\n    result.v = (point1.v + point2.v) / 2;\r\n  }\r\n  return result;\r\n}\r\n","import jet from \"../Assets/jet.glb\";\r\n// https://sketchfab.com/3d-models/jet-fighter-ba8c9ca82b204222834997996dfc1e1e\r\nimport coke from \"../Assets/coke.glb\";\r\n// https://sketchfab.com/3d-models/soda-cans-4e0be610db9646929d8be84491f1a72f\r\nimport cone from \"../Assets/cone.glb\";\r\n// https://sketchfab.com/3d-models/ice-cream-71b833e5c6ea487c88eec12743ea14a6\r\nimport dino from \"../Assets/dino.glb\";\r\n// https://sketchfab.com/3d-models/dinosaur-fbx-5d618571be5e4a97ba3f31950530a06e\r\nimport dog from \"../Assets/dog.glb\";\r\n// https://sketchfab.com/3d-models/low-poly-doggy-1c8c763518ab4751bfcddf0b6a34011a\r\nimport flower from \"../Assets/flower.glb\";\r\n// https://sketchfab.com/3d-models/lily-uvw-a0bc2a2cedb94cb69c6b61e1705a987f\r\nimport grogu from \"../Assets/grogu.glb\";\r\n// https://sketchfab.com/3d-models/grogu-baby-yoda-the-child-mandalorian-d33948cb580f40b899d399aa7af5ede5\r\nimport helmet from \"../Assets/helmet.glb\";\r\n// https://sketchfab.com/3d-models/achilles-helmet-7db0659c137242849bb166d3a7d901bf\r\nimport pc from \"../Assets/pc.glb\";\r\nimport reptile from \"../Assets/reptile.glb\";\r\n// https://sketchfab.com/3d-models/rpg-reptile-mage-0641cc113cfb4a6ba7269aa696ae1512\r\nimport tie from \"../Assets/tie.glb\";\r\n// https://sketchfab.com/3d-models/tie-5bcaa60ed5ce4a51b4233aed418f2280\r\n\r\nimport { useGLTF } from \"@react-three/drei\";\r\nimport fillWithPoints from \"./fillWithPoints/fillWithPoints\";\r\nimport { useEffect, useRef, useState } from \"react\";\r\n\r\nconst models = [\r\n  jet,\r\n  dino,\r\n  grogu,\r\n  flower,\r\n  dog,\r\n  reptile,\r\n  helmet,\r\n  cone,\r\n  tie,\r\n  pc,\r\n  coke,\r\n];\r\nexport default function useModels({ nextModel }) {\r\n  const i = useRef(0);\r\n  const [model, setModel] = useState(models[i.current]);\r\n  const [data, setData] = useState([]);\r\n  const prevData = useRef();\r\n\r\n  useEffect(() => {\r\n    if (!nextModel) return;\r\n    i.current++;\r\n    if (i.current === models.length) i.current = 0;\r\n    setModel(models[i.current]);\r\n  }, [nextModel]);\r\n\r\n  const { nodes } = useGLTF(model);\r\n\r\n  useEffect(() => {\r\n    setData((prev) => {\r\n      prevData.current = prev;\r\n      return fillWithPoints(nodes, 5);\r\n    });\r\n  }, [nodes]);\r\n  return [data, prevData];\r\n}\r\n\r\nuseGLTF.preload(jet);\r\nuseGLTF.preload(dino);\r\nuseGLTF.preload(grogu);\r\nuseGLTF.preload(reptile);\r\nuseGLTF.preload(flower);\r\nuseGLTF.preload(cone);\r\nuseGLTF.preload(tie);\r\nuseGLTF.preload(dog);\r\nuseGLTF.preload(helmet);\r\nuseGLTF.preload(pc);\r\nuseGLTF.preload(coke);\r\n","import dino from \"../Assets/dino.json\";\r\nimport jet from \"../Assets/jet.json\";\r\n\r\nimport { useEffect, useRef, useState } from \"react\";\r\n\r\nconst models = [jet, dino]\r\n  //\r\n  .map((model) => {\r\n    const [data, colors] = model;\r\n    data.forEach((point) => {\r\n      const colorIndex = point[3];\r\n      point[3] = colors[colorIndex];\r\n    });\r\n    return data;\r\n  });\r\n\r\nexport default function useData({ nextModel }) {\r\n  const i = useRef(-1);\r\n  const [data, setdata] = useState([]);\r\n  const prevData = useRef();\r\n\r\n  useEffect(() => {\r\n    i.current++;\r\n    if (i.current === models.length) i.current = 0;\r\n    setdata((prev) => {\r\n      prevData.current = prev;\r\n      return models[i.current];\r\n    });\r\n  }, [nextModel]);\r\n  return [data, prevData];\r\n}\r\n","import { useEffect, useRef } from \"react\";\r\n\r\nimport { useFrame } from \"@react-three/fiber\";\r\nimport { useBufferAnimation } from \"./useBufferAnimation\";\r\nimport useModels from \"./useModels\";\r\nimport useData from \"./useData\";\r\n\r\nconst CONFIG = {\r\n  duration: 1.5,\r\n  totalDelay: 1.75,\r\n};\r\n\r\nexport default function Test({ nextModel }) {\r\n  const animating = useRef(true);\r\n  const meshRef = useRef();\r\n\r\n  // const [data, prevData] = useModels({ nextModel });\r\n  const [data, prevData] = useData({ nextModel });\r\n\r\n  const [geo, mat] = useBufferAnimation({\r\n    data,\r\n    prevData,\r\n    CONFIG,\r\n    animating,\r\n  });\r\n\r\n  useFrame(() => {\r\n    if (!meshRef.current) return;\r\n    if (animating.current) {\r\n      const uniforms = meshRef.current.material.uniforms;\r\n      uniforms.time.value += 1 / 60;\r\n      if (uniforms.time.value > CONFIG.duration + CONFIG.totalDelay) {\r\n        animating.current = false;\r\n      }\r\n    }\r\n  });\r\n\r\n  return (\r\n    <>\r\n      {mat && (\r\n        <mesh\r\n          frustumCulled={false}\r\n          ref={meshRef}\r\n          material={mat}\r\n          geometry={geo}\r\n        />\r\n      )}\r\n    </>\r\n  );\r\n}\r\n","import * as THREE from \"three\";\r\nimport { useMemo, useRef } from \"react\";\r\n\r\nimport {\r\n  InstancedPrefabBufferGeometry,\r\n  StandardAnimationMaterial,\r\n  ShaderChunk,\r\n} from \"three-bas\";\r\n\r\nexport const useBufferAnimation = ({ data, prevData, CONFIG, animating }) => {\r\n  // const geometryRef = useRef(null);\r\n  // const materialRef = useRef(null);\r\n\r\n  return useMemo(() => {\r\n    if (!data.length) return [null, null];\r\n\r\n    const length = data.length;\r\n\r\n    // const prevLength = prevPositions.current.length;\r\n    // const maxLength = Math.max(length, prevLength);\r\n    const maxLength = length;\r\n\r\n    const prefab = new THREE.SphereBufferGeometry(1, 5, 5);\r\n    // const geometry = new InstancedPrefabBufferGeometry(prefab, maxLength);\r\n    const geometry = new InstancedPrefabBufferGeometry(prefab, length);\r\n\r\n    const startPositionBuffer = geometry.createAttribute(\"startPosition\", 3);\r\n    const endPositionBuffer = geometry.createAttribute(\"endPosition\", 3);\r\n    const startTimeBuffer = geometry.createAttribute(\"startTime\", 1);\r\n    const startColorBuffer = geometry.createAttribute(\"startColor\", 3);\r\n    const endColorBuffer = geometry.createAttribute(\"endColor\", 3);\r\n\r\n    const color = new THREE.Color();\r\n    const tmpa = [];\r\n    let colorArray;\r\n\r\n    //will use this to track buffer index position\r\n    let counter = 0;\r\n\r\n    //loop through all new points\r\n    for (let i = 0; i < length; i++) {\r\n      const prevDataPoint = prevData.current[i];\r\n      //start position\r\n      if (prevDataPoint) {\r\n        tmpa[0] = prevDataPoint[0];\r\n        tmpa[1] = prevDataPoint[1];\r\n        tmpa[2] = prevDataPoint[2];\r\n      } else {\r\n        //case where new points are added\r\n        tmpa[0] = 0;\r\n        tmpa[1] = -100;\r\n        tmpa[2] = 0;\r\n      }\r\n      geometry.setPrefabData(startPositionBuffer, counter, tmpa);\r\n      //end position\r\n      tmpa[0] = data[i][0];\r\n      tmpa[1] = data[i][1];\r\n      tmpa[2] = data[i][2];\r\n      geometry.setPrefabData(endPositionBuffer, counter, tmpa);\r\n\r\n      //delay\r\n      tmpa[0] = (CONFIG.totalDelay / maxLength) * counter;\r\n      geometry.setPrefabData(startTimeBuffer, counter, tmpa);\r\n\r\n      //start color\r\n      colorArray = prevDataPoint ? prevDataPoint[3] : data[i][3];\r\n      geometry.setPrefabData(startColorBuffer, counter, colorArray);\r\n\r\n      //end color\r\n      colorArray = data[i][3];\r\n      geometry.setPrefabData(endColorBuffer, counter, colorArray);\r\n\r\n      counter++;\r\n    }\r\n\r\n    const uniforms = {\r\n      time: { value: 0 },\r\n      duration: { value: CONFIG.duration },\r\n    };\r\n    const vertexParameters = [\r\n      \"uniform float time;\",\r\n      \"uniform float duration;\",\r\n\r\n      \"attribute vec3 startPosition;\",\r\n      \"attribute vec3 endPosition;\",\r\n      \"attribute float startTime;\",\r\n      \"attribute vec3 startColor;\",\r\n      \"attribute vec3 endColor;\",\r\n    ];\r\n    const vertexPosition = [\r\n      \"float progress = clamp(time - startTime, 0.0, duration) / duration;\",\r\n      \"progress = easeCubicInOut(progress);\",\r\n      \"transformed += mix(startPosition, endPosition, progress);\",\r\n    ];\r\n\r\n    const material = new StandardAnimationMaterial({\r\n      roughness: 0.5,\r\n      metalness: 0.5,\r\n      vertexColors: THREE.VertexColors,\r\n      // flatShading: true,\r\n      // opacity: 1,\r\n      // transparent: true,\r\n      uniforms,\r\n      vertexParameters,\r\n      vertexFunctions: [ShaderChunk[\"ease_cubic_in_out\"]],\r\n      vertexPosition,\r\n      vertexColor: [\"vColor = mix(startColor, endColor, progress);\"],\r\n    });\r\n\r\n    // geometryRef.current && geometryRef.current.dispose();\r\n    // materialRef.current && materialRef.current.dispose();\r\n    // geometryRef.current = geometry;\r\n    // materialRef.current = material;\r\n    animating.current = true;\r\n    return [geometry, material];\r\n  }, [data, prevData, CONFIG, animating]);\r\n};\r\n"],"sourceRoot":""}