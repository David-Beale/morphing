(this["webpackJsonpobject-particles"]=this["webpackJsonpobject-particles"]||[]).push([[4],{124:function(t,n,e){"use strict";e.d(n,"a",(function(){return f})),e.d(n,"b",(function(){return p})),e.d(n,"c",(function(){return s}));var a=e(1),o=e(2),r=e(3),c=e(4),i=e(11),l=function(t){Object(r.a)(e,t);var n=Object(c.a)(e);function e(t,o){var r;return Object(a.a)(this,e),r=n.call(this),t.uniformValues&&(console.warn("THREE.BAS - `uniformValues` is deprecated. Put their values directly into the parameters."),Object.keys(t.uniformValues).forEach((function(n){t[n]=t.uniformValues[n]})),delete t.uniformValues),Object.keys(t).forEach((function(n){r[n]=t[n]})),r.setValues(t),r.uniforms=i.UniformsUtils.merge([o,t.uniforms||{}]),r.setUniformValues(t),r}return Object(o.a)(e,[{key:"setUniformValues",value:function(t){var n=this;t&&Object.keys(t).forEach((function(e){e in n.uniforms&&(n.uniforms[e].value=t[e])}))}},{key:"stringifyChunk",value:function(t){return this[t]?"string"===typeof this[t]?this[t]:this[t].join("\n"):""}}]),e}(i.ShaderMaterial),s=function(t){Object(r.a)(e,t);var n=Object(c.a)(e);function e(t){var o;return Object(a.a)(this,e),(o=n.call(this,t,i.ShaderLib.physical.uniforms)).lights=!0,o.extensions=o.extensions||{},o.extensions.derivatives=!0,o.vertexShader=o.concatVertexShader(),o.fragmentShader=o.concatFragmentShader(),o}return Object(o.a)(e,[{key:"concatVertexShader",value:function(){return i.ShaderLib.standard.vertexShader.replace("void main() {","\n        ".concat(this.stringifyChunk("vertexParameters"),"\n        ").concat(this.stringifyChunk("varyingParameters"),"\n        ").concat(this.stringifyChunk("vertexFunctions"),"\n\n        void main() {\n          ").concat(this.stringifyChunk("vertexInit"),"\n        ")).replace("#include <beginnormal_vertex>","\n        #include <beginnormal_vertex>\n\n        ".concat(this.stringifyChunk("vertexNormal"),"\n        ")).replace("#include <begin_vertex>","\n        #include <begin_vertex>\n\n        ".concat(this.stringifyChunk("vertexPosition"),"\n        ").concat(this.stringifyChunk("vertexColor"),"\n        ")).replace("#include <morphtarget_vertex>","\n        #include <morphtarget_vertex>\n\n        ".concat(this.stringifyChunk("vertexPostMorph"),"\n        ")).replace("#include <skinning_vertex>","\n        #include <skinning_vertex>\n\n        ".concat(this.stringifyChunk("vertexPostSkinning"),"\n        "))}},{key:"concatFragmentShader",value:function(){return i.ShaderLib.standard.fragmentShader.replace("void main() {","\n        ".concat(this.stringifyChunk("fragmentParameters"),"\n        ").concat(this.stringifyChunk("varyingParameters"),"\n        ").concat(this.stringifyChunk("fragmentFunctions"),"\n\n        void main() {\n          ").concat(this.stringifyChunk("fragmentInit"),"\n        ")).replace("#include <map_fragment>","\n        ".concat(this.stringifyChunk("fragmentDiffuse"),"\n        ").concat(this.stringifyChunk("fragmentMap")||"#include <map_fragment>","\n\n        ")).replace("#include <emissivemap_fragment>","\n        ".concat(this.stringifyChunk("fragmentEmissive"),"\n\n        #include <emissivemap_fragment>\n        ")).replace("#include <roughnessmap_fragment>","\n        float roughnessFactor = roughness;\n        ".concat(this.stringifyChunk("fragmentRoughness"),"\n        #ifdef USE_ROUGHNESSMAP\n\n        vec4 texelRoughness = texture2D( roughnessMap, vUv );\n          roughnessFactor *= texelRoughness.g;\n        #endif\n        ")).replace("#include <metalnessmap_fragment>","\n        float metalnessFactor = metalness;\n        ".concat(this.stringifyChunk("fragmentMetalness"),"\n\n        #ifdef USE_METALNESSMAP\n          vec4 texelMetalness = texture2D( metalnessMap, vUv );\n          metalnessFactor *= texelMetalness.b;\n        #endif\n        "))}}]),e}(l),f=(i.BufferGeometry,i.BufferGeometry,function(t){Object(r.a)(e,t);var n=Object(c.a)(e);function e(t,o){var r;return Object(a.a)(this,e),(r=n.call(this)).prefabGeometry=t,r.copy(t),r.instanceCount=o,r.prefabCount=o,r}return Object(o.a)(e,[{key:"createAttribute",value:function(t,n,e){var a=new Float32Array(this.prefabCount*n),o=new i.InstancedBufferAttribute(a,n);if(this.setAttribute(t,o),e)for(var r=[],c=0;c<this.prefabCount;c++)e(r,c,this.prefabCount),this.setPrefabData(o,c,r);return o}},{key:"setPrefabData",value:function(t,n,e){for(var a=n*(t="string"===typeof t?this.attributes[t]:t).itemSize,o=0;o<t.itemSize;o++)t.array[a++]=e[o]}}]),e}(i.InstancedBufferGeometry)),u=function(t,n,e){var a=t.vertices[n.a],o=t.vertices[n.b],r=t.vertices[n.c];return(e=e||new i.Vector3).x=(a.x+o.x+r.x)/3,e.y=(a.y+o.y+r.y)/3,e.z=(a.z+o.z+r.z)/3,e},p=(i.BufferGeometry,i.BufferGeometry,{catmull_rom_spline:"vec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, vec2 c) {\n    vec4 v0 = (p2 - p0) * c.x;\n    vec4 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nvec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t, vec2 c) {\n    vec3 v0 = (p2 - p0) * c.x;\n    vec3 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t, vec2 c) {\n    vec2 v0 = (p2 - p0) * c.x;\n    vec2 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return vec2((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t, vec2 c) {\n    float v0 = (p2 - p0) * c.x;\n    float v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return float((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nivec4 getCatmullRomSplineIndices(float l, float p) {\n    float index = floor(p);\n    int i0 = int(max(0.0, index - 1.0));\n    int i1 = int(index);\n    int i2 = int(min(index + 1.0, l));\n    int i3 = int(min(index + 2.0, l));\n    return ivec4(i0, i1, i2, i3);\n}\nivec4 getCatmullRomSplineIndicesClosed(float l, float p) {\n    float index = floor(p);\n    int i0 = int(index == 0.0 ? l : index - 1.0);\n    int i1 = int(index);\n    int i2 = int(mod(index + 1.0, l));\n    int i3 = int(mod(index + 2.0, l));\n    return ivec4(i0, i1, i2, i3);\n}\n",cubic_bezier:"vec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\n}\nvec2 cubicBezier(vec2 p0, vec2 c0, vec2 c1, vec2 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\n}\n",ease_back_in:"float easeBackIn(float p, float amplitude) {\n    return p * p * ((amplitude + 1.0) * p - amplitude);\n}\nfloat easeBackIn(float p) {\n    return easeBackIn(p, 1.70158);\n}\nfloat easeBackIn(float t, float b, float c, float d, float amplitude) {\n    return b + easeBackIn(t / d, amplitude) * c;\n}\nfloat easeBackIn(float t, float b, float c, float d) {\n    return b + easeBackIn(t / d) * c;\n}\n",ease_back_in_out:"float easeBackInOut(float p, float amplitude) {\n    amplitude *= 1.525;\n    return ((p *= 2.0) < 1.0) ? 0.5 * p * p * ((amplitude + 1.0) * p - amplitude) : 0.5 * ((p -= 2.0) * p * ((amplitude + 1.0) * p + amplitude) + 2.0);\n}\nfloat easeBackInOut(float p) {\n    return easeBackInOut(p, 1.70158);\n}\nfloat easeBackInOut(float t, float b, float c, float d, float amplitude) {\n    return b + easeBackInOut(t / d, amplitude) * c;\n}\nfloat easeBackInOut(float t, float b, float c, float d) {\n    return b + easeBackInOut(t / d) * c;\n}\n",ease_back_out:"float easeBackOut(float p, float amplitude) {\n    return ((p = p - 1.0) * p * ((amplitude + 1.0) * p + amplitude) + 1.0);\n}\nfloat easeBackOut(float p) {\n    return easeBackOut(p, 1.70158);\n}\nfloat easeBackOut(float t, float b, float c, float d, float amplitude) {\n    return b + easeBackOut(t / d, amplitude) * c;\n}\nfloat easeBackOut(float t, float b, float c, float d) {\n    return b + easeBackOut(t / d) * c;\n}\n",ease_bezier:"float easeBezier(float p, vec4 curve) {\n    float ip = 1.0 - p;\n    return (3.0 * ip * ip * p * curve.xy + 3.0 * ip * p * p * curve.zw + p * p * p).y;\n}\nfloat easeBezier(float t, float b, float c, float d, vec4 curve) {\n    return b + easeBezier(t / d, curve) * c;\n}\n",ease_bounce_in:"float easeBounceIn(float p) {\n    if ((p = 1.0 - p) < 1.0 / 2.75) {\n        return 1.0 - (7.5625 * p * p);\n    } else if (p < 2.0 / 2.75) {\n        return 1.0 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);\n    } else if (p < 2.5 / 2.75) {\n        return 1.0 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);\n    }\n    return 1.0 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);\n}\nfloat easeBounceIn(float t, float b, float c, float d) {\n    return b + easeBounceIn(t / d) * c;\n}\n",ease_bounce_in_out:"float easeBounceInOut(float p) {\n    bool invert = (p < 0.5);\n    p = invert ? (1.0 - (p * 2.0)) : ((p * 2.0) - 1.0);\n    if (p < 1.0 / 2.75) {\n        p = 7.5625 * p * p;\n    } else if (p < 2.0 / 2.75) {\n        p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\n    } else if (p < 2.5 / 2.75) {\n        p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\n    } else {\n        p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\n    }\n    return invert ? (1.0 - p) * 0.5 : p * 0.5 + 0.5;\n}\nfloat easeBounceInOut(float t, float b, float c, float d) {\n    return b + easeBounceInOut(t / d) * c;\n}\n",ease_bounce_out:"float easeBounceOut(float p) {\n    if (p < 1.0 / 2.75) {\n        return 7.5625 * p * p;\n    } else if (p < 2.0 / 2.75) {\n        return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\n    } else if (p < 2.5 / 2.75) {\n        return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\n    }\n    return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\n}\nfloat easeBounceOut(float t, float b, float c, float d) {\n    return b + easeBounceOut(t / d) * c;\n}\n",ease_circ_in:"float easeCircIn(float p) {\n    return -(sqrt(1.0 - p * p) - 1.0);\n}\nfloat easeCircIn(float t, float b, float c, float d) {\n    return b + easeCircIn(t / d) * c;\n}\n",ease_circ_in_out:"float easeCircInOut(float p) {\n    return ((p *= 2.0) < 1.0) ? -0.5 * (sqrt(1.0 - p * p) - 1.0) : 0.5 * (sqrt(1.0 - (p -= 2.0) * p) + 1.0);\n}\nfloat easeCircInOut(float t, float b, float c, float d) {\n    return b + easeCircInOut(t / d) * c;\n}\n",ease_circ_out:"float easeCircOut(float p) {\n  return sqrt(1.0 - (p = p - 1.0) * p);\n}\nfloat easeCircOut(float t, float b, float c, float d) {\n  return b + easeCircOut(t / d) * c;\n}\n",ease_cubic_in:"float easeCubicIn(float t) {\n  return t * t * t;\n}\nfloat easeCubicIn(float t, float b, float c, float d) {\n  return b + easeCubicIn(t / d) * c;\n}\n",ease_cubic_in_out:"float easeCubicInOut(float t) {\n  return (t /= 0.5) < 1.0 ? 0.5 * t * t * t : 0.5 * ((t-=2.0) * t * t + 2.0);\n}\nfloat easeCubicInOut(float t, float b, float c, float d) {\n  return b + easeCubicInOut(t / d) * c;\n}\n",ease_cubic_out:"float easeCubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\nfloat easeCubicOut(float t, float b, float c, float d) {\n  return b + easeCubicOut(t / d) * c;\n}\n",ease_elastic_in:"float easeElasticIn(float p, float amplitude, float period) {\n    float p1 = max(amplitude, 1.0);\n    float p2 = period / min(amplitude, 1.0);\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\n    return -(p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2));\n}\nfloat easeElasticIn(float p) {\n    return easeElasticIn(p, 1.0, 0.3);\n}\nfloat easeElasticIn(float t, float b, float c, float d, float amplitude, float period) {\n    return b + easeElasticIn(t / d, amplitude, period) * c;\n}\nfloat easeElasticIn(float t, float b, float c, float d) {\n    return b + easeElasticIn(t / d) * c;\n}\n",ease_elastic_in_out:"float easeElasticInOut(float p, float amplitude, float period) {\n    float p1 = max(amplitude, 1.0);\n    float p2 = period / min(amplitude, 1.0);\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\n    return ((p *= 2.0) < 1.0) ? -0.5 * (p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2)) : p1 * pow(2.0, -10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2) * 0.5 + 1.0;\n}\nfloat easeElasticInOut(float p) {\n    return easeElasticInOut(p, 1.0, 0.3);\n}\nfloat easeElasticInOut(float t, float b, float c, float d, float amplitude, float period) {\n    return b + easeElasticInOut(t / d, amplitude, period) * c;\n}\nfloat easeElasticInOut(float t, float b, float c, float d) {\n    return b + easeElasticInOut(t / d) * c;\n}\n",ease_elastic_out:"float easeElasticOut(float p, float amplitude, float period) {\n    float p1 = max(amplitude, 1.0);\n    float p2 = period / min(amplitude, 1.0);\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\n    return p1 * pow(2.0, -10.0 * p) * sin((p - p3) * PI2 / p2) + 1.0;\n}\nfloat easeElasticOut(float p) {\n    return easeElasticOut(p, 1.0, 0.3);\n}\nfloat easeElasticOut(float t, float b, float c, float d, float amplitude, float period) {\n    return b + easeElasticOut(t / d, amplitude, period) * c;\n}\nfloat easeElasticOut(float t, float b, float c, float d) {\n    return b + easeElasticOut(t / d) * c;\n}\n",ease_expo_in:"float easeExpoIn(float p) {\n    return pow(2.0, 10.0 * (p - 1.0));\n}\nfloat easeExpoIn(float t, float b, float c, float d) {\n    return b + easeExpoIn(t / d) * c;\n}\n",ease_expo_in_out:"float easeExpoInOut(float p) {\n    return ((p *= 2.0) < 1.0) ? 0.5 * pow(2.0, 10.0 * (p - 1.0)) : 0.5 * (2.0 - pow(2.0, -10.0 * (p - 1.0)));\n}\nfloat easeExpoInOut(float t, float b, float c, float d) {\n    return b + easeExpoInOut(t / d) * c;\n}\n",ease_expo_out:"float easeExpoOut(float p) {\n  return 1.0 - pow(2.0, -10.0 * p);\n}\nfloat easeExpoOut(float t, float b, float c, float d) {\n  return b + easeExpoOut(t / d) * c;\n}\n",ease_quad_in:"float easeQuadIn(float t) {\n    return t * t;\n}\nfloat easeQuadIn(float t, float b, float c, float d) {\n  return b + easeQuadIn(t / d) * c;\n}\n",ease_quad_in_out:"float easeQuadInOut(float t) {\n    float p = 2.0 * t * t;\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\nfloat easeQuadInOut(float t, float b, float c, float d) {\n    return b + easeQuadInOut(t / d) * c;\n}\n",ease_quad_out:"float easeQuadOut(float t) {\n  return -t * (t - 2.0);\n}\nfloat easeQuadOut(float t, float b, float c, float d) {\n  return b + easeQuadOut(t / d) * c;\n}\n",ease_quart_in:"float easeQuartIn(float t) {\n  return t * t * t * t;\n}\nfloat easeQuartIn(float t, float b, float c, float d) {\n  return b + easeQuartIn(t / d) * c;\n}\n",ease_quart_in_out:"float easeQuartInOut(float t) {\n    return t < 0.5 ? 8.0 * pow(t, 4.0) : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\nfloat easeQuartInOut(float t, float b, float c, float d) {\n    return b + easeQuartInOut(t / d) * c;\n}\n",ease_quart_out:"float easeQuartOut(float t) {\n  return 1.0 - pow(1.0 - t, 4.0);\n}\nfloat easeQuartOut(float t, float b, float c, float d) {\n  return b + easeQuartOut(t / d) * c;\n}\n",ease_quint_in:"float easeQuintIn(float t) {\n    return pow(t, 5.0);\n}\nfloat easeQuintIn(float t, float b, float c, float d) {\n    return b + easeQuintIn(t / d) * c;\n}\n",ease_quint_in_out:"float easeQuintInOut(float t) {\n    return (t /= 0.5) < 1.0 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2.0) * t * t * t * t + 2.0);\n}\nfloat easeQuintInOut(float t, float b, float c, float d) {\n    return b + easeQuintInOut(t / d) * c;\n}\n",ease_quint_out:"float easeQuintOut(float t) {\n    return (t -= 1.0) * t * t * t * t + 1.0;\n}\nfloat easeQuintOut(float t, float b, float c, float d) {\n    return b + easeQuintOut(t / d) * c;\n}\n",ease_sine_in:"float easeSineIn(float p) {\n  return -cos(p * 1.57079632679) + 1.0;\n}\nfloat easeSineIn(float t, float b, float c, float d) {\n  return b + easeSineIn(t / d) * c;\n}\n",ease_sine_in_out:"float easeSineInOut(float p) {\n  return -0.5 * (cos(PI * p) - 1.0);\n}\nfloat easeSineInOut(float t, float b, float c, float d) {\n  return b + easeSineInOut(t / d) * c;\n}\n",ease_sine_out:"float easeSineOut(float p) {\n  return sin(p * 1.57079632679);\n}\nfloat easeSineOut(float t, float b, float c, float d) {\n  return b + easeSineOut(t / d) * c;\n}\n",quadratic_bezier:"vec3 quadraticBezier(vec3 p0, vec3 c0, vec3 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\n}\nvec2 quadraticBezier(vec2 p0, vec2 c0, vec2 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\n}",quaternion_rotation:"vec3 rotateVector(vec4 q, vec3 v) {\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\n    float halfAngle = angle * 0.5;\n    return vec4(axis.xyz * sin(halfAngle), cos(halfAngle));\n}\n",quaternion_slerp:"vec4 quatSlerp(vec4 q0, vec4 q1, float t) {\n    float s = 1.0 - t;\n    float c = dot(q0, q1);\n    float dir = -1.0;    float sqrSn = 1.0 - c * c;\n    if (sqrSn > 2.220446049250313e-16) {\n        float sn = sqrt(sqrSn);\n        float len = atan(sn, c * dir);\n        s = sin(s * len) / sn;\n        t = sin(t * len) / sn;\n    }\n    float tDir = t * dir;\n    return normalize(q0 * s + q1 * tDir);\n}\n"});function d(t,n,e,a,o){this.key=t,this.start=n,this.duration=e,this.transition=a,this.compiler=o,this.trail=0}function v(){this.duration=0,this.timeKey="tTime",this.segments={},this.__key=0}d.prototype.compile=function(){return this.compiler(this)},Object.defineProperty(d.prototype,"end",{get:function(){return this.start+this.duration}}),v.segmentDefinitions={},v.register=function(t,n){return v.segmentDefinitions[t]=n,n},v.prototype.add=function(t,n,e){var a=eval,o=this.duration;void 0!==e?("number"===typeof e?o=e:"string"===typeof e&&a("start"+e),this.duration=Math.max(this.duration,o+t)):this.duration+=t;for(var r,c=Object.keys(n),i=0;i<c.length;i++)r=c[i],this.processTransition(r,n[r],o,t)},v.prototype.processTransition=function(t,n,e,a){var o=v.segmentDefinitions[t],r=this.segments[t];r||(r=this.segments[t]=[]),void 0===n.from&&(0===r.length?n.from=o.defaultFrom:n.from=r[r.length-1].transition.to),r.push(new d((this.__key++).toString(),e,a,n,o.compiler))},v.prototype.compile=function(){for(var t,n=[],e=Object.keys(this.segments),a=0;a<e.length;a++)t=this.segments[e[a]],this.fillGaps(t),t.forEach((function(t){n.push(t.compile())}));return n},v.prototype.fillGaps=function(t){if(0!==t.length){for(var n,e,a=0;a<t.length-1;a++)n=t[a],e=t[a+1],n.trail=e.start-n.end;(n=t[t.length-1]).trail=this.duration-n.end}},v.prototype.getTransformCalls=function(t){var n=this.timeKey;return this.segments[t]?this.segments[t].map((function(t){return"applyTransform".concat(t.key,"(").concat(n,", transformed);")})).join("\n"):""};var m=function(t,n,e){var a=(n.x||0).toPrecision(e),o=(n.y||0).toPrecision(e),r=(n.z||0).toPrecision(e);return"vec3 ".concat(t," = vec3(").concat(a,", ").concat(o,", ").concat(r,");")},b=function(t,n,e){var a=(n.x||0).toPrecision(e),o=(n.y||0).toPrecision(e),r=(n.z||0).toPrecision(e),c=(n.w||0).toPrecision(e);return"vec4 ".concat(t," = vec4(").concat(a,", ").concat(o,", ").concat(r,", ").concat(c,");")},h=function(t){return"\n    float cDelay".concat(t.key," = ").concat(t.start.toPrecision(4),";\n    float cDuration").concat(t.key," = ").concat(t.duration.toPrecision(4),";\n    ")},g=function(t){return 0===t.duration?"float progress = 1.0;":"\n      float progress = clamp(time - cDelay".concat(t.key,", 0.0, cDuration").concat(t.key,") / cDuration").concat(t.key,";\n      ").concat(t.transition.ease?"progress = ".concat(t.transition.ease,"(progress").concat(t.transition.easeParams?", ".concat(t.transition.easeParams.map((function(t){return t.toPrecision(4)})).join(", ")):"",");"):"","\n      ")},y=function(t){var n=t.start.toPrecision(4),e=(t.end+t.trail).toPrecision(4);return"if (time < ".concat(n," || time > ").concat(e,") return;")},O={compiler:function(t){return"\n    ".concat(h(t),"\n    ").concat(m("cTranslateFrom".concat(t.key),t.transition.from,2),"\n    ").concat(m("cTranslateTo".concat(t.key),t.transition.to,2),"\n    \n    void applyTransform").concat(t.key,"(float time, inout vec3 v) {\n    \n      ").concat(y(t),"\n      ").concat(g(t),"\n    \n      v += mix(cTranslateFrom").concat(t.key,", cTranslateTo").concat(t.key,", progress);\n    }\n    ")},defaultFrom:new i.Vector3(0,0,0)};v.register("translate",O);var _={compiler:function(t){var n=t.transition.origin;return"\n    ".concat(h(t),"\n    ").concat(m("cScaleFrom".concat(t.key),t.transition.from,2),"\n    ").concat(m("cScaleTo".concat(t.key),t.transition.to,2),"\n    ").concat(n?m("cOrigin".concat(t.key),n,2):"","\n    \n    void applyTransform").concat(t.key,"(float time, inout vec3 v) {\n    \n      ").concat(y(t),"\n      ").concat(g(t),"\n    \n      ").concat(n?"v -= cOrigin".concat(t.key,";"):"","\n      v *= mix(cScaleFrom").concat(t.key,", cScaleTo").concat(t.key,", progress);\n      ").concat(n?"v += cOrigin".concat(t.key,";"):"","\n    }\n    ")},defaultFrom:new i.Vector3(1,1,1)};v.register("scale",_);var k={compiler:function(t){var n=new i.Vector4(t.transition.from.axis.x,t.transition.from.axis.y,t.transition.from.axis.z,t.transition.from.angle),e=t.transition.to.axis||t.transition.from.axis,a=new i.Vector4(e.x,e.y,e.z,t.transition.to.angle),o=t.transition.origin;return"\n    ".concat(h(t),"\n    ").concat(b("cRotationFrom".concat(t.key),n,8),"\n    ").concat(b("cRotationTo".concat(t.key),a,8),"\n    ").concat(o?m("cOrigin".concat(t.key),o,2):"","\n    \n    void applyTransform").concat(t.key,"(float time, inout vec3 v) {\n      ").concat(y(t),"\n      ").concat(g(t),"\n\n      ").concat(o?"v -= cOrigin".concat(t.key,";"):"","\n      vec3 axis = normalize(mix(cRotationFrom").concat(t.key,".xyz, cRotationTo").concat(t.key,".xyz, progress));\n      float angle = mix(cRotationFrom").concat(t.key,".w, cRotationTo").concat(t.key,".w, progress);\n      vec4 q = quatFromAxisAngle(axis, angle);\n      v = rotateVector(q, v);\n      ").concat(o?"v += cOrigin".concat(t.key,";"):"","\n    }\n    ")},defaultFrom:{axis:new i.Vector3,angle:0}};v.register("rotate",k)}}]);
//# sourceMappingURL=4.e90ebe58.chunk.js.map