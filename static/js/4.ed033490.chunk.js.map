{"version":3,"sources":["../node_modules/three-bas/dist/bas.module.js","../node_modules/three-stdlib/loaders/DRACOLoader.js","../node_modules/three-stdlib/libs/MeshoptDecoder.js","../node_modules/three-stdlib/loaders/GLTFLoader.js","../node_modules/@react-three/drei/core/useGLTF.js"],"names":["BaseAnimationMaterial","parameters","uniforms","uniformValues","console","warn","Object","keys","forEach","key","setValues","UniformsUtils","merge","setUniformValues","values","value","name","this","join","ShaderMaterial","StandardAnimationMaterial","ShaderLib","lights","extensions","derivatives","vertexShader","concatVertexShader","fragmentShader","concatFragmentShader","standard","replace","stringifyChunk","InstancedPrefabBufferGeometry","BufferGeometry","prefab","count","prefabGeometry","copy","instanceCount","prefabCount","itemSize","factory","buffer","Float32Array","attribute","InstancedBufferAttribute","setAttribute","data","i","setPrefabData","prefabIndex","offset","attributes","j","array","InstancedBufferGeometry","Utils","geometry","face","v","a","vertices","b","c","Vector3","x","y","z","ShaderChunk","catmull_rom_spline","cubic_bezier","ease_back_in","ease_back_in_out","ease_back_out","ease_bezier","ease_bounce_in","ease_bounce_in_out","ease_bounce_out","ease_circ_in","ease_circ_in_out","ease_circ_out","ease_cubic_in","ease_cubic_in_out","ease_cubic_out","ease_elastic_in","ease_elastic_in_out","ease_elastic_out","ease_expo_in","ease_expo_in_out","ease_expo_out","ease_quad_in","ease_quad_in_out","ease_quad_out","ease_quart_in","ease_quart_in_out","ease_quart_out","ease_quint_in","ease_quint_in_out","ease_quint_out","ease_sine_in","ease_sine_in_out","ease_sine_out","quadratic_bezier","quaternion_rotation","quaternion_slerp","TimelineSegment","start","duration","transition","compiler","trail","Timeline","timeKey","segments","__key","prototype","compile","defineProperty","get","segmentDefinitions","register","definition","add","transitions","positionOffset","_eval","eval","undefined","Math","max","length","processTransition","from","defaultFrom","to","push","toString","fillGaps","s","s0","s1","end","getTransformCalls","t","map","TimelineChunks","n","p","toPrecision","w","segment","ease","easeParams","startTime","endTime","TranslationSegment","ScaleSegment","origin","RotationSegment","fromAxisAngle","Vector4","axis","angle","toAxis","toAxisAngle","_taskCache","WeakMap","DRACOLoader","manager","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","position","normal","color","uv","defaultAttributeTypes","path","config","url","onLoad","onProgress","onError","loader","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","taskConfig","attributeIDs","attributeTypes","useUniqueIDs","decodeGeometry","then","catch","callback","type","BYTES_PER_ELEMENT","worker","taskKey","JSON","stringify","has","cachedTask","promise","byteLength","Error","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","id","message","_createGeometry","_releaseTask","set","geometryData","index","setIndex","BufferAttribute","responseType","_initDecoder","useJS","WebAssembly","librariesPending","_loadLibrary","all","libraries","jsContent","wasmBinary","fn","DRACOWorker","body","substring","indexOf","lastIndexOf","URL","createObjectURL","Blob","Worker","_taskCosts","_taskLoad","onmessage","e","error","sort","log","terminate","Loader","decodeAttribute","draco","decoder","dracoGeometry","attributeName","attributeType","numComponents","num_components","numValues","num_points","dataType","DT_FLOAT32","Int8Array","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","Uint32Array","DT_UINT32","getDracoDataType","ptr","_malloc","GetAttributeDataArrayForAllPoints","HEAPF32","slice","_free","onModuleLoaded","DracoDecoderModule","module","Decoder","decoderBuffer","DecoderBuffer","Init","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","error_msg","self","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","numIndices","num_faces","GetTrianglesUInt32Array","decodeIndex","destroy","buffers","attr","MeshoptDecoder","detector","wasmpack","supported","instance","wasm","validate","instantiate","result","ch","charCodeAt","write","unpack","exports","__wasm_call_ctors","decode","fun","target","size","source","filter","sbrk","count4","tp","sp","heap","memory","res","subarray","filters","NONE","OCTAHEDRAL","QUATERNION","EXPONENTIAL","decoders","ATTRIBUTES","TRIANGLES","INDICES","ready","decodeVertexBuffer","meshopt_decodeVertexBuffer","decodeIndexBuffer","meshopt_decodeIndexBuffer","decodeIndexSequence","meshopt_decodeIndexSequence","decodeGltfBuffer","mode","GLTFLoader","dracoLoader","ktx2Loader","meshoptDecoder","pluginCallbacks","parser","GLTFMaterialsClearcoatExtension","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFMaterialsTransmissionExtension","GLTFLightsExtension","GLTFMeshoptCompression","resourcePath","scope","LoaderUtils","extractUrlBase","itemStart","_onError","itemError","itemEnd","parse","gltf","splice","content","plugins","decodeText","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","json","asset","version","GLTFParser","crossOrigin","fileLoader","plugin","extensionsUsed","extensionName","extensionsRequired","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS","GLTFMaterialsPbrSpecularGlossinessExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","setExtensions","setPlugins","GLTFRegistry","objects","object","remove","removeAll","KHR_LIGHTS_PUNCTUAL","KHR_MATERIALS_CLEARCOAT","KHR_MATERIALS_TRANSMISSION","KHR_TEXTURE_BASISU","EXT_TEXTURE_WEBP","EXT_MESHOPT_COMPRESSION","cache","refs","uses","nodeDefs","nodes","nodeIndex","nodeLength","nodeDef","light","_addNodeRef","lightIndex","cacheKey","dependency","lightNode","lightDef","Color","fromArray","range","DirectionalLight","PointLight","distance","SpotLight","spot","innerConeAngle","outerConeAngle","PI","penumbra","decay","intensity","createUniqueName","_loadLight","_getNodeRef","MeshBasicMaterial","materialParams","materialDef","pending","opacity","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","baseColorTexture","assignTexture","materialIndex","materials","MeshPhysicalMaterial","extension","clearcoatFactor","clearcoat","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessTexture","clearcoatNormalTexture","scale","clearcoatNormalScale","Vector2","transmissionFactor","transmission","transmissionTexture","textureIndex","textureDef","textures","images","options","loadTextureImage","isSupported","textureLoader","uri","handler","getHandler","detectSupport","loadTexture","image","Image","src","onload","onerror","height","bufferView","bufferViews","extensionDef","getDependency","byteOffset","stride","byteStride","ArrayBuffer","BINARY_EXTENSION_CHUNK_TYPES","headerView","DataView","header","magic","getUint32","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","preload","primitive","bufferViewIndex","gltfAttributeMap","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","threeAttributeName","toLowerCase","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","normalized","decodeDracoFile","texture","transform","clone","rotation","repeat","texCoord","needsUpdate","GLTFMeshStandardSGMaterial","params","isGLTFSpecularGlossinessMaterial","specularMapParsFragmentChunk","glossinessMapParsFragmentChunk","specularMapFragmentChunk","glossinessMapFragmentChunk","lightPhysicalFragmentChunk","specular","setHex","glossiness","specularMap","glossinessMap","_extraUniforms","onBeforeCompile","shader","uniformName","defineProperties","defines","USE_SPECULARMAP","USE_GLOSSINESSMAP","USE_UV","metalness","roughness","metalnessMap","roughnessMap","MeshStandardMaterial","specularGlossinessParams","pbrSpecularGlossiness","diffuseFactor","diffuseTexture","emissive","glossinessFactor","specularFactor","specularGlossinessTexture","specGlossMapDef","material","fog","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","TangentSpaceNormalMap","normalScale","displacementMap","displacementScale","displacementBias","alphaMap","envMap","envMapIntensity","refractionRatio","GLTFCubicSplineInterpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","valueSize","Interpolant","beforeStart_","copySampleValue_","afterEnd_","interpolate_","i1","t0","t1","stride2","stride3","td","pp","ppp","offset1","offset0","s2","s3","p0","m0","p1","m1","WEBGL_CONSTANTS","WEBGL_FILTERS","NearestFilter","LinearFilter","NearestMipmapNearestFilter","LinearMipmapNearestFilter","NearestMipmapLinearFilter","LinearMipmapLinearFilter","WEBGL_WRAPPINGS","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","WEBGL_TYPE_SIZES","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","LINEAR","InterpolateLinear","STEP","InterpolateDiscrete","ALPHA_MODES","resolveURL","test","addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","assignExtrasToUserData","gltfDef","extras","assign","updateMorphTargets","mesh","meshDef","il","morphTargetInfluences","targetNames","morphTargetDictionary","createPrimitiveKey","primitiveDef","dracoExtension","indices","createAttributesKey","attributesKey","getNormalizedComponentScale","constructor","associations","Map","primitiveCache","meshCache","cameraCache","lightCache","nodeNamesUsed","createImageBitmap","navigator","userAgent","ImageBitmapLoader","TextureLoader","setCrossOrigin","_invokeAll","ext","_markDefs","beforeRoot","getDependencies","dependencies","scene","scenes","animations","cameras","afterRoot","skinDefs","skins","meshDefs","meshes","skinIndex","skinLength","joints","isBone","skin","isSkinnedMesh","camera","ref","func","unshift","loadScene","loadNode","_invokeOne","loadMesh","loadAccessor","loadBufferView","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","defs","def","bufferIndex","bufferDef","bufferViewDef","accessorIndex","sparse","pendingBufferViews","bufferAttribute","TypedArray","elementBytes","itemBytes","ibSlice","floor","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","itemSizeIndices","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setX","setY","setZ","setW","webkitURL","sourceURI","isObjectURL","hasAlpha","mimeType","colorType","getUint8","blob","isImageBitmapLoader","imageBitmap","CanvasTexture","revokeObjectURL","flipY","format","RGBFormat","sampler","samplers","magFilter","minFilter","wrapS","wrapT","mapName","mapDef","gltfReference","extendTexture","useVertexTangents","tangent","useVertexColors","useFlatShading","useSkinning","useMorphTargets","morphAttributes","useMorphNormals","isPoints","uuid","pointsMaterial","PointsMaterial","Material","call","sizeAttenuation","isLine","lineMaterial","LineBasicMaterial","cachedMaterial","skinning","vertexColors","flatShading","morphTargets","morphNormals","vertexTangents","uv2","materialType","materialExtensions","sgExtension","getMaterialType","extendParams","kmuExtension","metallicFactor","roughnessFactor","metallicRoughnessTexture","extendMaterialParams","doubleSided","side","DoubleSide","alphaMode","transparent","depthWrite","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","emissiveFactor","emissiveTexture","createMaterial","encoding","sRGBEncoding","originalName","sanitizedName","PropertyBinding","sanitizeNodeName","primitives","createDracoPrimitive","decodePrimitive","addPrimitiveAttributes","cached","geometryPromise","meshIndex","depthTest","FrontSide","loadGeometries","results","geometries","SkinnedMesh","skinWeight","normalizeSkinWeights","toTrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LineSegments","Line","LineLoop","Points","assignFinalMaterial","group","Group","cameraIndex","cameraDef","PerspectiveCamera","MathUtils","radToDeg","yfov","aspectRatio","znear","zfar","OrthographicCamera","xmag","ymag","skinDef","skinEntry","inverseBindMatrices","accessor","animationIndex","animationDef","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","channel","node","input","output","inputAccessors","outputAccessors","targets","tracks","inputAccessor","outputAccessor","updateMatrix","matrixAutoUpdate","TypedKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","targetName","interpolation","traverse","isMesh","outputArray","scaled","jl","track","createInterpolant","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","AnimationClip","o","nodeName","meshPromise","createNodeMesh","createNodeAttachment","Bone","Object3D","matrix","Matrix4","applyMatrix4","quaternion","sceneIndex","sceneDef","nodeIds","buildNodeHierachy","nodeId","parentObject","pendingJoints","jointNodes","bones","boneInverses","jointNode","mat","bind","Skeleton","matrixWorld","children","child","assignAttributeAccessor","gltfAttributeName","box","Box3","min","boxScale","multiplyScalar","maxDisplacement","vector","abs","expandByVector","boundingBox","sphere","Sphere","getCenter","center","radius","distanceTo","boundingSphere","computeBounds","hasMorphPosition","hasMorphNormal","pendingPositionAccessors","pendingNormalAccessors","pendingAccessor","morphPositions","morphTargetsRelative","addMorphTargets","drawMode","getIndex","getAttribute","numberOfTriangles","newIndices","getX","newGeometry","useDraco","useMeshopt","extendLoader","setDecoderPath","setDRACOLoader","setMeshoptDecoder","useGLTF","useMeshOpt","useLoader","clear"],"mappings":"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","file":"static/js/4.ed033490.chunk.js","sourcesContent":["import { ShaderMaterial, UniformsUtils, ShaderLib, RGBADepthPacking, BufferGeometry, BufferAttribute, InstancedBufferGeometry, InstancedBufferAttribute, Vector3, Math as Math$1, Vector4 } from 'three';\n\nclass BaseAnimationMaterial extends ShaderMaterial {\n  constructor (parameters, uniforms) {\n    super();\n\n    if (parameters.uniformValues) {\n      console.warn('THREE.BAS - `uniformValues` is deprecated. Put their values directly into the parameters.');\n\n      Object.keys(parameters.uniformValues).forEach((key) => {\n        parameters[key] = parameters.uniformValues[key];\n      });\n\n      delete parameters.uniformValues;\n    }\n\n    // copy parameters to (1) make use of internal #define generation\n    // and (2) prevent 'x is not a property of this material' warnings.\n    Object.keys(parameters).forEach((key) => {\n      this[key] = parameters[key];\n    });\n\n    // override default parameter values\n    this.setValues(parameters);\n\n    // override uniforms\n    this.uniforms = UniformsUtils.merge([uniforms, parameters.uniforms || {}]);\n\n    // set uniform values from parameters that affect uniforms\n    this.setUniformValues(parameters);\n  }\n\n  setUniformValues (values) {\n    if (!values) return;\n\n    const keys = Object.keys(values);\n\n    keys.forEach((key) => {\n      key in this.uniforms && (this.uniforms[key].value = values[key]);\n    });\n  }\n\n  stringifyChunk (name) {\n    let value;\n\n    if (!this[name]) {\n      value = '';\n    }\n    else if (typeof this[name] ===  'string') {\n      value = this[name];\n    }\n    else {\n      value = this[name].join('\\n');\n    }\n\n    return value;\n  }\n}\n\nclass BasicAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshBasicMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_basic/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['basic'].uniforms);\n\n    this.lights = false;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.basic.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.basic.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n  }\n}\n\nclass LambertAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshLambertMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_lambert/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   * @constructor\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['lambert'].uniforms);\n\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.lambert.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.lambert.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n  }\n}\n\nclass PhongAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshPhongMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_phong/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   * @constructor\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['phong'].uniforms);\n\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.phong.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.phong.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n      .replace(\n        '#include <lights_phong_fragment>',\n        `\n        #include <lights_phong_fragment>\n        ${this.stringifyChunk('fragmentSpecular')}\n        `\n      )\n  }\n}\n\nclass StandardAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshStandardMaterial with custom shader chunks.\n   *\n   * @see http://three-bas-examples.surge.sh/examples/materials_standard/\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['physical'].uniforms);\n\n    this.lights = true;\n    this.extensions = (this.extensions || {});\n    this.extensions.derivatives = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.standard.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.standard.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n      .replace(\n        '#include <roughnessmap_fragment>',\n        `\n        float roughnessFactor = roughness;\n        ${this.stringifyChunk('fragmentRoughness')}\n        #ifdef USE_ROUGHNESSMAP\n\n        vec4 texelRoughness = texture2D( roughnessMap, vUv );\n          roughnessFactor *= texelRoughness.g;\n        #endif\n        `\n      )\n      .replace(\n        '#include <metalnessmap_fragment>',\n        `\n        float metalnessFactor = metalness;\n        ${this.stringifyChunk('fragmentMetalness')}\n\n        #ifdef USE_METALNESSMAP\n          vec4 texelMetalness = texture2D( metalnessMap, vUv );\n          metalnessFactor *= texelMetalness.b;\n        #endif\n        `\n      )\n  }\n}\n\nclass ToonAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshToonMaterial with custom shader chunks.\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['toon'].uniforms);\n\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.toon.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.toon.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n  }\n}\n\nclass PointsAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.PointsMaterial with custom shader chunks.\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   * @constructor\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['points'].uniforms);\n\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.points.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.points.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <premultiplied_alpha_fragment>',\n        `\n        ${this.stringifyChunk('fragmentShape')}\n\n        #include <premultiplied_alpha_fragment>\n        `\n      )\n  }\n}\n\nclass DepthAnimationMaterial extends BaseAnimationMaterial {\n  constructor (parameters) {\n    super(parameters, ShaderLib['depth'].uniforms);\n\n    this.depthPacking = RGBADepthPacking;\n    this.clipping = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = ShaderLib['depth'].fragmentShader;\n  }\n\n  concatVertexShader () {\n    return ShaderLib.depth.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n}\n\nclass DistanceAnimationMaterial extends BaseAnimationMaterial {\n  constructor (parameters) {\n    super(parameters, ShaderLib['distanceRGBA'].uniforms);\n\n    this.depthPacking = RGBADepthPacking;\n    this.clipping = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = ShaderLib['distanceRGBA'].fragmentShader;\n  }\n\n  concatVertexShader () {\n    return ShaderLib.distanceRGBA.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n}\n\nclass PrefabBufferGeometry extends BufferGeometry {\n  /**\n   * A BufferGeometry where a 'prefab' geometry is repeated a number of times.\n   *\n   * @param {Geometry|BufferGeometry} prefab The Geometry instance to repeat.\n   * @param {Number} count The number of times to repeat the geometry.\n   */\n  constructor (prefab, count) {\n    super();\n\n    /**\n     * A reference to the prefab geometry used to create this instance.\n     * @type {Geometry|BufferGeometry}\n     */\n    this.prefabGeometry = prefab;\n    this.isPrefabBufferGeometry = prefab.isBufferGeometry;\n\n    /**\n     * Number of prefabs.\n     * @type {Number}\n     */\n    this.prefabCount = count;\n\n    /**\n     * Number of vertices of the prefab.\n     * @type {Number}\n     */\n    if (this.isPrefabBufferGeometry) {\n      this.prefabVertexCount = prefab.attributes.position.count;\n    }\n    else {\n      this.prefabVertexCount = prefab.vertices.length;\n    }\n\n    this.bufferIndices();\n    this.bufferPositions();\n  }\n\n  bufferIndices () {\n    let prefabIndices = [];\n    let prefabIndexCount;\n\n    if (this.isPrefabBufferGeometry) {\n      if (this.prefabGeometry.index) {\n        prefabIndexCount = this.prefabGeometry.index.count;\n        prefabIndices = this.prefabGeometry.index.array;\n      }\n      else {\n        prefabIndexCount = this.prefabVertexCount;\n\n        for (let i = 0; i < prefabIndexCount; i++) {\n          prefabIndices.push(i);\n        }\n      }\n    }\n    else {\n      const prefabFaceCount = this.prefabGeometry.faces.length;\n      prefabIndexCount = prefabFaceCount * 3;\n\n      for (let i = 0; i < prefabFaceCount; i++) {\n        const face = this.prefabGeometry.faces[i];\n        prefabIndices.push(face.a, face.b, face.c);\n      }\n    }\n\n    const indexBuffer = new Uint32Array(this.prefabCount * prefabIndexCount);\n\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n\n    for (let i = 0; i < this.prefabCount; i++) {\n      for (let k = 0; k < prefabIndexCount; k++) {\n        indexBuffer[i * prefabIndexCount + k] = prefabIndices[k] + i * this.prefabVertexCount;\n      }\n    }\n  }\n\n  bufferPositions () {\n    const positionBuffer = this.createAttribute('position', 3).array;\n\n    if (this.isPrefabBufferGeometry) {\n      const positions = this.prefabGeometry.attributes.position.array;\n\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 3) {\n          positionBuffer[offset    ] = positions[j * 3];\n          positionBuffer[offset + 1] = positions[j * 3 + 1];\n          positionBuffer[offset + 2] = positions[j * 3 + 2];\n        }\n      }\n    }\n    else {\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 3) {\n          const prefabVertex = this.prefabGeometry.vertices[j];\n\n          positionBuffer[offset    ] = prefabVertex.x;\n          positionBuffer[offset + 1] = prefabVertex.y;\n          positionBuffer[offset + 2] = prefabVertex.z;\n        }\n      }\n    }\n  }\n\n  bufferUvs () {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n\n    if (this.isPrefabBufferGeometry) {\n      const uvs = this.prefabGeometry.attributes.uv.array;\n\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 2) {\n          uvBuffer[offset    ] = uvs[j * 2];\n          uvBuffer[offset + 1] = uvs[j * 2 + 1];\n        }\n      }\n    } else {\n      const prefabFaceCount = this.prefabGeometry.faces.length;\n      const uvs = [];\n\n      for (let i = 0; i < prefabFaceCount; i++) {\n        const face = this.prefabGeometry.faces[i];\n        const uv = this.prefabGeometry.faceVertexUvs[0][i];\n\n        uvs[face.a] = uv[0];\n        uvs[face.b] = uv[1];\n        uvs[face.c] = uv[2];\n      }\n\n      for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n        for (let j = 0; j < this.prefabVertexCount; j++, offset += 2) {\n          const uv = uvs[j];\n\n          uvBuffer[offset] = uv.x;\n          uvBuffer[offset + 1] = uv.y;\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates a BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each prefab upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPrefabData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.prefabCount * this.prefabVertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.prefabCount; i++) {\n        factory(data, i, this.prefabCount);\n        this.setPrefabData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  }\n\n  /**\n   * Sets data for all vertices of a prefab at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {Number} prefabIndex Index of the prefab in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setPrefabData (attribute, prefabIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = prefabIndex * this.prefabVertexCount * attribute.itemSize;\n\n    for (let i = 0; i < this.prefabVertexCount; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\n\nclass MultiPrefabBufferGeometry extends BufferGeometry {\n  /**\n   * A BufferGeometry where a 'prefab' geometry array is repeated a number of times.\n   *\n   * @param {Array} prefabs An array with Geometry instances to repeat.\n   * @param {Number} repeatCount The number of times to repeat the array of Geometries.\n   * @constructor\n   */\n  constructor (prefabs, repeatCount) {\n    super();\n\n    if (Array.isArray(prefabs)) {\n      this.prefabGeometries = prefabs;\n    } else {\n      this.prefabGeometries = [prefabs];\n    }\n\n    this.prefabGeometriesCount = this.prefabGeometries.length;\n\n    /**\n     * Number of prefabs.\n     * @type {Number}\n     */\n    this.prefabCount = repeatCount * this.prefabGeometriesCount;\n    /**\n     * How often the prefab array is repeated.\n     * @type {Number}\n     */\n    this.repeatCount = repeatCount;\n\n    /**\n     * Array of vertex counts per prefab.\n     * @type {Array}\n     */\n    this.prefabVertexCounts = this.prefabGeometries.map(p => p.isBufferGeometry ? p.attributes.position.count : p.vertices.length);\n    /**\n     * Total number of vertices for one repetition of the prefabs\n     * @type {number}\n     */\n    this.repeatVertexCount = this.prefabVertexCounts.reduce((r, v) => r + v, 0);\n\n    this.bufferIndices();\n    this.bufferPositions();\n  }\n\n  bufferIndices () {\n    let repeatIndexCount = 0;\n\n    this.prefabIndices = this.prefabGeometries.map(geometry => {\n      let indices = [];\n\n      if (geometry.isBufferGeometry) {\n        if (geometry.index) {\n          indices = geometry.index.array;\n        } else {\n          for (let i = 0; i < geometry.attributes.position.count; i++) {\n            indices.push(i);\n          }\n        }\n      } else {\n        for (let i = 0; i < geometry.faces.length; i++) {\n          const face = geometry.faces[i];\n          indices.push(face.a, face.b, face.c);\n        }\n      }\n\n      repeatIndexCount += indices.length;\n\n      return indices;\n    });\n\n    const indexBuffer = new Uint32Array(repeatIndexCount * this.repeatCount);\n    let indexOffset = 0;\n    let prefabOffset = 0;\n\n    for (let i = 0; i < this.prefabCount; i++) {\n      const index = i % this.prefabGeometriesCount;\n      const indices = this.prefabIndices[index];\n      const vertexCount = this.prefabVertexCounts[index];\n\n      for (let j = 0; j < indices.length; j++) {\n        indexBuffer[indexOffset++] = indices[j] + prefabOffset;\n      }\n\n      prefabOffset += vertexCount;\n    }\n\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n  }\n\n  bufferPositions () {\n    const positionBuffer = this.createAttribute('position', 3).array;\n\n    const prefabPositions = this.prefabGeometries.map((geometry, i) => {\n      let positions;\n\n      if (geometry.isBufferGeometry) {\n        positions = geometry.attributes.position.array;\n      } else {\n\n        const vertexCount = this.prefabVertexCounts[i];\n\n        positions = [];\n\n        for (let j = 0, offset = 0; j < vertexCount; j++) {\n          const prefabVertex = geometry.vertices[j];\n\n          positions[offset++] = prefabVertex.x;\n          positions[offset++] = prefabVertex.y;\n          positions[offset++] = prefabVertex.z;\n        }\n      }\n\n      return positions;\n    });\n\n    for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n      const index = i % this.prefabGeometries.length;\n      const vertexCount = this.prefabVertexCounts[index];\n      const positions = prefabPositions[index];\n\n      for (let j = 0; j < vertexCount; j++) {\n        positionBuffer[offset++] = positions[j * 3];\n        positionBuffer[offset++] = positions[j * 3 + 1];\n        positionBuffer[offset++] = positions[j * 3 + 2];\n      }\n    }\n  }\n\n  /**\n   * Creates a BufferAttribute with UV coordinates.\n   */\n  bufferUvs () {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n    const prefabUvs = this.prefabGeometries.map((geometry, i) => {\n      let uvs;\n\n      if (geometry.isBufferGeometry) {\n        if (!geometry.attributes.uv) {\n          console.error('No UV found in prefab geometry', geometry);\n        }\n\n        uvs = geometry.attributes.uv.array;\n      } else {\n        const prefabFaceCount = this.prefabIndices[i].length / 3;\n        const uvObjects = [];\n\n        for (let j = 0; j < prefabFaceCount; j++) {\n          const face = geometry.faces[j];\n          const uv = geometry.faceVertexUvs[0][j];\n\n          uvObjects[face.a] = uv[0];\n          uvObjects[face.b] = uv[1];\n          uvObjects[face.c] = uv[2];\n        }\n\n        uvs = [];\n\n        for (let k = 0; k < uvObjects.length; k++) {\n          uvs[k * 2] = uvObjects[k].x;\n          uvs[k * 2 + 1] = uvObjects[k].y;\n        }\n      }\n\n      return uvs;\n    });\n\n    for (let i = 0, offset = 0; i < this.prefabCount; i++) {\n\n      const index = i % this.prefabGeometries.length;\n      const vertexCount = this.prefabVertexCounts[index];\n      const uvs = prefabUvs[index];\n\n      for (let j = 0; j < vertexCount; j++) {\n        uvBuffer[offset++] = uvs[j * 2];\n        uvBuffer[offset++] = uvs[j * 2 + 1];\n      }\n    }\n  }\n\n  /**\n   * Creates a BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each prefab upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPrefabData.\n   *\n   * @returns {BufferAttribute}\n   */\n   createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.repeatCount * this.repeatVertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.prefabCount; i++) {\n        factory(data, i, this.prefabCount);\n        this.setPrefabData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n   }\n\n   /**\n   * Sets data for all vertices of a prefab at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {Number} prefabIndex Index of the prefab in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setPrefabData (attribute, prefabIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    const prefabGeometryIndex = prefabIndex % this.prefabGeometriesCount;\n    const prefabGeometryVertexCount = this.prefabVertexCounts[prefabGeometryIndex];\n    const whole = (prefabIndex / this.prefabGeometriesCount | 0) * this.prefabGeometriesCount;\n    const wholeOffset = whole * this.repeatVertexCount;\n    const part = prefabIndex - whole;\n    let partOffset = 0;\n    let i = 0;\n\n    while(i < part) {\n      partOffset += this.prefabVertexCounts[i++];\n    }\n\n    let offset = (wholeOffset + partOffset) * attribute.itemSize;\n\n    for (let i = 0; i < prefabGeometryVertexCount; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\n\nclass InstancedPrefabBufferGeometry extends InstancedBufferGeometry {\n  /**\n   * A wrapper around THREE.InstancedBufferGeometry, which is more memory efficient than PrefabBufferGeometry, but requires the ANGLE_instanced_arrays extension.\n   *\n   * @param {BufferGeometry} prefab The Geometry instance to repeat.\n   * @param {Number} count The number of times to repeat the geometry.\n   */\n  constructor (prefab, count) {\n    super();\n\n    this.prefabGeometry = prefab;\n    this.copy(prefab);\n\n    this.instanceCount = count;\n    this.prefabCount = count;\n  }\n\n  /**\n   * Creates a BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each prefab upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPrefabData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.prefabCount * itemSize);\n    const attribute = new InstancedBufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.prefabCount; i++) {\n        factory(data, i, this.prefabCount);\n        this.setPrefabData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  };\n\n  /**\n   * Sets data for a prefab at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {Number} prefabIndex Index of the prefab in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setPrefabData (attribute, prefabIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = prefabIndex * attribute.itemSize;\n\n    for (let j = 0; j < attribute.itemSize; j++) {\n      attribute.array[offset++] = data[j];\n    }\n  };\n}\n\n/**\n * Collection of utility functions.\n * @namespace\n */\nconst Utils = {\n  /**\n   * Duplicates vertices so each face becomes separate.\n   * Same as THREE.ExplodeModifier.\n   *\n   * @param {THREE.Geometry} geometry Geometry instance to modify.\n   */\n  separateFaces: function (geometry) {\n    let vertices = [];\n\n    for (let i = 0, il = geometry.faces.length; i < il; i++) {\n      let n = vertices.length;\n      let face = geometry.faces[i];\n\n      let a = face.a;\n      let b = face.b;\n      let c = face.c;\n\n      let va = geometry.vertices[a];\n      let vb = geometry.vertices[b];\n      let vc = geometry.vertices[c];\n\n      vertices.push(va.clone());\n      vertices.push(vb.clone());\n      vertices.push(vc.clone());\n\n      face.a = n;\n      face.b = n + 1;\n      face.c = n + 2;\n    }\n\n    geometry.vertices = vertices;\n  },\n\n  /**\n   * Compute the centroid (center) of a THREE.Face3.\n   *\n   * @param {THREE.Geometry} geometry Geometry instance the face is in.\n   * @param {THREE.Face3} face Face object from the THREE.Geometry.faces array\n   * @param {THREE.Vector3=} v Optional vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  computeCentroid: function(geometry, face, v) {\n    let a = geometry.vertices[face.a];\n    let b = geometry.vertices[face.b];\n    let c = geometry.vertices[face.c];\n\n    v = v || new Vector3();\n\n    v.x = (a.x + b.x + c.x) / 3;\n    v.y = (a.y + b.y + c.y) / 3;\n    v.z = (a.z + b.z + c.z) / 3;\n\n    return v;\n  },\n\n  /**\n   * Get a random vector between box.min and box.max.\n   *\n   * @param {THREE.Box3} box THREE.Box3 instance.\n   * @param {THREE.Vector3=} v Optional vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  randomInBox: function(box, v) {\n    v = v || new Vector3();\n\n    v.x = Math$1.randFloat(box.min.x, box.max.x);\n    v.y = Math$1.randFloat(box.min.y, box.max.y);\n    v.z = Math$1.randFloat(box.min.z, box.max.z);\n\n    return v;\n  },\n\n  /**\n   * Get a random axis for quaternion rotation.\n   *\n   * @param {THREE.Vector3=} v Option vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  randomAxis: function(v) {\n    v = v || new Vector3();\n\n    v.x = Math$1.randFloatSpread(2.0);\n    v.y = Math$1.randFloatSpread(2.0);\n    v.z = Math$1.randFloatSpread(2.0);\n    v.normalize();\n\n    return v;\n  },\n\n  /**\n   * Create a THREE.BAS.DepthAnimationMaterial for shadows from a THREE.SpotLight or THREE.DirectionalLight by copying relevant shader chunks.\n   * Uniform values must be manually synced between the source material and the depth material.\n   *\n   * @see {@link http://three-bas-examples.surge.sh/examples/shadows/}\n   *\n   * @param {THREE.BAS.BaseAnimationMaterial} sourceMaterial Instance to get the shader chunks from.\n   * @returns {THREE.BAS.DepthAnimationMaterial}\n   */\n  createDepthAnimationMaterial: function(sourceMaterial) {\n    return new DepthAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  },\n\n  /**\n   * Create a THREE.BAS.DistanceAnimationMaterial for shadows from a THREE.PointLight by copying relevant shader chunks.\n   * Uniform values must be manually synced between the source material and the distance material.\n   *\n   * @see {@link http://three-bas-examples.surge.sh/examples/shadows/}\n   *\n   * @param {THREE.BAS.BaseAnimationMaterial} sourceMaterial Instance to get the shader chunks from.\n   * @returns {THREE.BAS.DistanceAnimationMaterial}\n   */\n  createDistanceAnimationMaterial: function(sourceMaterial) {\n    return new DistanceAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  }\n};\n\nclass ModelBufferGeometry extends BufferGeometry {\n  /**\n   * A THREE.BufferGeometry for animating individual faces of a THREE.Geometry.\n   *\n   * @param {THREE.Geometry} model The THREE.Geometry to base this geometry on.\n   * @param {Object=} options\n   * @param {Boolean=} options.computeCentroids If true, a centroids will be computed for each face and stored in THREE.BAS.ModelBufferGeometry.centroids.\n   * @param {Boolean=} options.localizeFaces If true, the positions for each face will be stored relative to the centroid. This is useful if you want to rotate or scale faces around their center.\n   */\n  constructor (model, options) {\n    super();\n\n    /**\n     * A reference to the geometry used to create this instance.\n     * @type {THREE.Geometry}\n     */\n    this.modelGeometry = model;\n\n    /**\n     * Number of faces of the model.\n     * @type {Number}\n     */\n    this.faceCount = this.modelGeometry.faces.length;\n\n    /**\n     * Number of vertices of the model.\n     * @type {Number}\n     */\n    this.vertexCount = this.modelGeometry.vertices.length;\n\n    options = options || {};\n    options.computeCentroids && this.computeCentroids();\n\n    this.bufferIndices();\n    this.bufferPositions(options.localizeFaces);\n  }\n\n  /**\n   * Computes a centroid for each face and stores it in THREE.BAS.ModelBufferGeometry.centroids.\n   */\n  computeCentroids () {\n    /**\n     * An array of centroids corresponding to the faces of the model.\n     *\n     * @type {Array}\n     */\n    this.centroids = [];\n\n    for (let i = 0; i < this.faceCount; i++) {\n      this.centroids[i] = Utils.computeCentroid(this.modelGeometry, this.modelGeometry.faces[i]);\n    }\n  }\n\n  bufferIndices () {\n    const indexBuffer = new Uint32Array(this.faceCount * 3);\n\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n\n    for (let i = 0, offset = 0; i < this.faceCount; i++, offset += 3) {\n      const face = this.modelGeometry.faces[i];\n\n      indexBuffer[offset    ] = face.a;\n      indexBuffer[offset + 1] = face.b;\n      indexBuffer[offset + 2] = face.c;\n    }\n  }\n\n  bufferPositions (localizeFaces) {\n    const positionBuffer = this.createAttribute('position', 3).array;\n    let i, offset;\n\n    if (localizeFaces === true) {\n      for (i = 0; i < this.faceCount; i++) {\n        const face = this.modelGeometry.faces[i];\n        const centroid = this.centroids ? this.centroids[i] : Utils.computeCentroid(this.modelGeometry, face);\n\n        const a = this.modelGeometry.vertices[face.a];\n        const b = this.modelGeometry.vertices[face.b];\n        const c = this.modelGeometry.vertices[face.c];\n\n        positionBuffer[face.a * 3]     = a.x - centroid.x;\n        positionBuffer[face.a * 3 + 1] = a.y - centroid.y;\n        positionBuffer[face.a * 3 + 2] = a.z - centroid.z;\n\n        positionBuffer[face.b * 3]     = b.x - centroid.x;\n        positionBuffer[face.b * 3 + 1] = b.y - centroid.y;\n        positionBuffer[face.b * 3 + 2] = b.z - centroid.z;\n\n        positionBuffer[face.c * 3]     = c.x - centroid.x;\n        positionBuffer[face.c * 3 + 1] = c.y - centroid.y;\n        positionBuffer[face.c * 3 + 2] = c.z - centroid.z;\n      }\n    }\n    else {\n      for (i = 0, offset = 0; i < this.vertexCount; i++, offset += 3) {\n        const vertex = this.modelGeometry.vertices[i];\n\n        positionBuffer[offset    ] = vertex.x;\n        positionBuffer[offset + 1] = vertex.y;\n        positionBuffer[offset + 2] = vertex.z;\n      }\n    }\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute with UV coordinates.\n   */\n  bufferUvs () {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n\n    for (let i = 0; i < this.faceCount; i++) {\n\n      const face = this.modelGeometry.faces[i];\n      let uv;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][0];\n      uvBuffer[face.a * 2]     = uv.x;\n      uvBuffer[face.a * 2 + 1] = uv.y;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][1];\n      uvBuffer[face.b * 2]     = uv.x;\n      uvBuffer[face.b * 2 + 1] = uv.y;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][2];\n      uvBuffer[face.c * 2]     = uv.x;\n      uvBuffer[face.c * 2 + 1] = uv.y;\n    }\n  }\n\n  /**\n   * Creates two THREE.BufferAttributes: skinIndex and skinWeight. Both are required for skinning.\n   */\n  bufferSkinning () {\n    const skinIndexBuffer = this.createAttribute('skinIndex', 4).array;\n    const skinWeightBuffer = this.createAttribute('skinWeight', 4).array;\n\n    for (let i = 0; i < this.vertexCount; i++) {\n      const skinIndex = this.modelGeometry.skinIndices[i];\n      const skinWeight = this.modelGeometry.skinWeights[i];\n\n      skinIndexBuffer[i * 4    ] = skinIndex.x;\n      skinIndexBuffer[i * 4 + 1] = skinIndex.y;\n      skinIndexBuffer[i * 4 + 2] = skinIndex.z;\n      skinIndexBuffer[i * 4 + 3] = skinIndex.w;\n\n      skinWeightBuffer[i * 4    ] = skinWeight.x;\n      skinWeightBuffer[i * 4 + 1] = skinWeight.y;\n      skinWeightBuffer[i * 4 + 2] = skinWeight.z;\n      skinWeightBuffer[i * 4 + 3] = skinWeight.w;\n    }\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {int} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each face upon creation. Accepts 3 arguments: data[], index and faceCount. Calls setFaceData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.vertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.faceCount; i++) {\n        factory(data, i, this.faceCount);\n        this.setFaceData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  }\n\n  /**\n   * Sets data for all vertices of a face at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|THREE.BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {int} faceIndex Index of the face in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setFaceData (attribute, faceIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = faceIndex * 3 * attribute.itemSize;\n\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\n\nclass PointBufferGeometry extends BufferGeometry {\n  /**\n   * A THREE.BufferGeometry consists of points.\n   * @param {Number} count The number of points.\n   * @constructor\n   */\n  constructor (count) {\n    super();\n\n    /**\n     * Number of points.\n     * @type {Number}\n     */\n    this.pointCount = count;\n\n    this.bufferPositions();\n  }\n\n  bufferPositions () {\n    this.createAttribute('position', 3);\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {Number} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each point upon creation. Accepts 3 arguments: data[], index and prefabCount. Calls setPointData.\n   *\n   * @returns {THREE.BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.pointCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n      for (let i = 0; i < this.pointCount; i++) {\n        factory(data, i, this.pointCount);\n        this.setPointData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  }\n\n  setPointData (attribute, pointIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = pointIndex * attribute.itemSize;\n\n    for (let j = 0; j < attribute.itemSize; j++) {\n      attribute.array[offset++] = data[j];\n    }\n  }\n}\n\nvar catmull_rom_spline = \"vec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, vec2 c) {\\n    vec4 v0 = (p2 - p0) * c.x;\\n    vec4 v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nvec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t, vec2 c) {\\n    vec3 v0 = (p2 - p0) * c.x;\\n    vec3 v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t, vec2 c) {\\n    vec2 v0 = (p2 - p0) * c.x;\\n    vec2 v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return vec2((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t, vec2 c) {\\n    float v0 = (p2 - p0) * c.x;\\n    float v1 = (p3 - p1) * c.y;\\n    float t2 = t * t;\\n    float t3 = t * t * t;\\n    return float((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\\n}\\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t) {\\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\\n}\\nivec4 getCatmullRomSplineIndices(float l, float p) {\\n    float index = floor(p);\\n    int i0 = int(max(0.0, index - 1.0));\\n    int i1 = int(index);\\n    int i2 = int(min(index + 1.0, l));\\n    int i3 = int(min(index + 2.0, l));\\n    return ivec4(i0, i1, i2, i3);\\n}\\nivec4 getCatmullRomSplineIndicesClosed(float l, float p) {\\n    float index = floor(p);\\n    int i0 = int(index == 0.0 ? l : index - 1.0);\\n    int i1 = int(index);\\n    int i2 = int(mod(index + 1.0, l));\\n    int i3 = int(mod(index + 2.0, l));\\n    return ivec4(i0, i1, i2, i3);\\n}\\n\";\n\nvar cubic_bezier = \"vec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\\n}\\nvec2 cubicBezier(vec2 p0, vec2 c0, vec2 c1, vec2 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\\n}\\n\";\n\nvar ease_back_in = \"float easeBackIn(float p, float amplitude) {\\n    return p * p * ((amplitude + 1.0) * p - amplitude);\\n}\\nfloat easeBackIn(float p) {\\n    return easeBackIn(p, 1.70158);\\n}\\nfloat easeBackIn(float t, float b, float c, float d, float amplitude) {\\n    return b + easeBackIn(t / d, amplitude) * c;\\n}\\nfloat easeBackIn(float t, float b, float c, float d) {\\n    return b + easeBackIn(t / d) * c;\\n}\\n\";\n\nvar ease_back_in_out = \"float easeBackInOut(float p, float amplitude) {\\n    amplitude *= 1.525;\\n    return ((p *= 2.0) < 1.0) ? 0.5 * p * p * ((amplitude + 1.0) * p - amplitude) : 0.5 * ((p -= 2.0) * p * ((amplitude + 1.0) * p + amplitude) + 2.0);\\n}\\nfloat easeBackInOut(float p) {\\n    return easeBackInOut(p, 1.70158);\\n}\\nfloat easeBackInOut(float t, float b, float c, float d, float amplitude) {\\n    return b + easeBackInOut(t / d, amplitude) * c;\\n}\\nfloat easeBackInOut(float t, float b, float c, float d) {\\n    return b + easeBackInOut(t / d) * c;\\n}\\n\";\n\nvar ease_back_out = \"float easeBackOut(float p, float amplitude) {\\n    return ((p = p - 1.0) * p * ((amplitude + 1.0) * p + amplitude) + 1.0);\\n}\\nfloat easeBackOut(float p) {\\n    return easeBackOut(p, 1.70158);\\n}\\nfloat easeBackOut(float t, float b, float c, float d, float amplitude) {\\n    return b + easeBackOut(t / d, amplitude) * c;\\n}\\nfloat easeBackOut(float t, float b, float c, float d) {\\n    return b + easeBackOut(t / d) * c;\\n}\\n\";\n\nvar ease_bezier = \"float easeBezier(float p, vec4 curve) {\\n    float ip = 1.0 - p;\\n    return (3.0 * ip * ip * p * curve.xy + 3.0 * ip * p * p * curve.zw + p * p * p).y;\\n}\\nfloat easeBezier(float t, float b, float c, float d, vec4 curve) {\\n    return b + easeBezier(t / d, curve) * c;\\n}\\n\";\n\nvar ease_bounce_in = \"float easeBounceIn(float p) {\\n    if ((p = 1.0 - p) < 1.0 / 2.75) {\\n        return 1.0 - (7.5625 * p * p);\\n    } else if (p < 2.0 / 2.75) {\\n        return 1.0 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);\\n    } else if (p < 2.5 / 2.75) {\\n        return 1.0 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);\\n    }\\n    return 1.0 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);\\n}\\nfloat easeBounceIn(float t, float b, float c, float d) {\\n    return b + easeBounceIn(t / d) * c;\\n}\\n\";\n\nvar ease_bounce_in_out = \"float easeBounceInOut(float p) {\\n    bool invert = (p < 0.5);\\n    p = invert ? (1.0 - (p * 2.0)) : ((p * 2.0) - 1.0);\\n    if (p < 1.0 / 2.75) {\\n        p = 7.5625 * p * p;\\n    } else if (p < 2.0 / 2.75) {\\n        p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\\n    } else if (p < 2.5 / 2.75) {\\n        p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\\n    } else {\\n        p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\\n    }\\n    return invert ? (1.0 - p) * 0.5 : p * 0.5 + 0.5;\\n}\\nfloat easeBounceInOut(float t, float b, float c, float d) {\\n    return b + easeBounceInOut(t / d) * c;\\n}\\n\";\n\nvar ease_bounce_out = \"float easeBounceOut(float p) {\\n    if (p < 1.0 / 2.75) {\\n        return 7.5625 * p * p;\\n    } else if (p < 2.0 / 2.75) {\\n        return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\\n    } else if (p < 2.5 / 2.75) {\\n        return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\\n    }\\n    return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\\n}\\nfloat easeBounceOut(float t, float b, float c, float d) {\\n    return b + easeBounceOut(t / d) * c;\\n}\\n\";\n\nvar ease_circ_in = \"float easeCircIn(float p) {\\n    return -(sqrt(1.0 - p * p) - 1.0);\\n}\\nfloat easeCircIn(float t, float b, float c, float d) {\\n    return b + easeCircIn(t / d) * c;\\n}\\n\";\n\nvar ease_circ_in_out = \"float easeCircInOut(float p) {\\n    return ((p *= 2.0) < 1.0) ? -0.5 * (sqrt(1.0 - p * p) - 1.0) : 0.5 * (sqrt(1.0 - (p -= 2.0) * p) + 1.0);\\n}\\nfloat easeCircInOut(float t, float b, float c, float d) {\\n    return b + easeCircInOut(t / d) * c;\\n}\\n\";\n\nvar ease_circ_out = \"float easeCircOut(float p) {\\n  return sqrt(1.0 - (p = p - 1.0) * p);\\n}\\nfloat easeCircOut(float t, float b, float c, float d) {\\n  return b + easeCircOut(t / d) * c;\\n}\\n\";\n\nvar ease_cubic_in = \"float easeCubicIn(float t) {\\n  return t * t * t;\\n}\\nfloat easeCubicIn(float t, float b, float c, float d) {\\n  return b + easeCubicIn(t / d) * c;\\n}\\n\";\n\nvar ease_cubic_in_out = \"float easeCubicInOut(float t) {\\n  return (t /= 0.5) < 1.0 ? 0.5 * t * t * t : 0.5 * ((t-=2.0) * t * t + 2.0);\\n}\\nfloat easeCubicInOut(float t, float b, float c, float d) {\\n  return b + easeCubicInOut(t / d) * c;\\n}\\n\";\n\nvar ease_cubic_out = \"float easeCubicOut(float t) {\\n  float f = t - 1.0;\\n  return f * f * f + 1.0;\\n}\\nfloat easeCubicOut(float t, float b, float c, float d) {\\n  return b + easeCubicOut(t / d) * c;\\n}\\n\";\n\nvar ease_elastic_in = \"float easeElasticIn(float p, float amplitude, float period) {\\n    float p1 = max(amplitude, 1.0);\\n    float p2 = period / min(amplitude, 1.0);\\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\\n    return -(p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2));\\n}\\nfloat easeElasticIn(float p) {\\n    return easeElasticIn(p, 1.0, 0.3);\\n}\\nfloat easeElasticIn(float t, float b, float c, float d, float amplitude, float period) {\\n    return b + easeElasticIn(t / d, amplitude, period) * c;\\n}\\nfloat easeElasticIn(float t, float b, float c, float d) {\\n    return b + easeElasticIn(t / d) * c;\\n}\\n\";\n\nvar ease_elastic_in_out = \"float easeElasticInOut(float p, float amplitude, float period) {\\n    float p1 = max(amplitude, 1.0);\\n    float p2 = period / min(amplitude, 1.0);\\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\\n    return ((p *= 2.0) < 1.0) ? -0.5 * (p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2)) : p1 * pow(2.0, -10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2) * 0.5 + 1.0;\\n}\\nfloat easeElasticInOut(float p) {\\n    return easeElasticInOut(p, 1.0, 0.3);\\n}\\nfloat easeElasticInOut(float t, float b, float c, float d, float amplitude, float period) {\\n    return b + easeElasticInOut(t / d, amplitude, period) * c;\\n}\\nfloat easeElasticInOut(float t, float b, float c, float d) {\\n    return b + easeElasticInOut(t / d) * c;\\n}\\n\";\n\nvar ease_elastic_out = \"float easeElasticOut(float p, float amplitude, float period) {\\n    float p1 = max(amplitude, 1.0);\\n    float p2 = period / min(amplitude, 1.0);\\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\\n    return p1 * pow(2.0, -10.0 * p) * sin((p - p3) * PI2 / p2) + 1.0;\\n}\\nfloat easeElasticOut(float p) {\\n    return easeElasticOut(p, 1.0, 0.3);\\n}\\nfloat easeElasticOut(float t, float b, float c, float d, float amplitude, float period) {\\n    return b + easeElasticOut(t / d, amplitude, period) * c;\\n}\\nfloat easeElasticOut(float t, float b, float c, float d) {\\n    return b + easeElasticOut(t / d) * c;\\n}\\n\";\n\nvar ease_expo_in = \"float easeExpoIn(float p) {\\n    return pow(2.0, 10.0 * (p - 1.0));\\n}\\nfloat easeExpoIn(float t, float b, float c, float d) {\\n    return b + easeExpoIn(t / d) * c;\\n}\\n\";\n\nvar ease_expo_in_out = \"float easeExpoInOut(float p) {\\n    return ((p *= 2.0) < 1.0) ? 0.5 * pow(2.0, 10.0 * (p - 1.0)) : 0.5 * (2.0 - pow(2.0, -10.0 * (p - 1.0)));\\n}\\nfloat easeExpoInOut(float t, float b, float c, float d) {\\n    return b + easeExpoInOut(t / d) * c;\\n}\\n\";\n\nvar ease_expo_out = \"float easeExpoOut(float p) {\\n  return 1.0 - pow(2.0, -10.0 * p);\\n}\\nfloat easeExpoOut(float t, float b, float c, float d) {\\n  return b + easeExpoOut(t / d) * c;\\n}\\n\";\n\nvar ease_quad_in = \"float easeQuadIn(float t) {\\n    return t * t;\\n}\\nfloat easeQuadIn(float t, float b, float c, float d) {\\n  return b + easeQuadIn(t / d) * c;\\n}\\n\";\n\nvar ease_quad_in_out = \"float easeQuadInOut(float t) {\\n    float p = 2.0 * t * t;\\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\\n}\\nfloat easeQuadInOut(float t, float b, float c, float d) {\\n    return b + easeQuadInOut(t / d) * c;\\n}\\n\";\n\nvar ease_quad_out = \"float easeQuadOut(float t) {\\n  return -t * (t - 2.0);\\n}\\nfloat easeQuadOut(float t, float b, float c, float d) {\\n  return b + easeQuadOut(t / d) * c;\\n}\\n\";\n\nvar ease_quart_in = \"float easeQuartIn(float t) {\\n  return t * t * t * t;\\n}\\nfloat easeQuartIn(float t, float b, float c, float d) {\\n  return b + easeQuartIn(t / d) * c;\\n}\\n\";\n\nvar ease_quart_in_out = \"float easeQuartInOut(float t) {\\n    return t < 0.5 ? 8.0 * pow(t, 4.0) : -8.0 * pow(t - 1.0, 4.0) + 1.0;\\n}\\nfloat easeQuartInOut(float t, float b, float c, float d) {\\n    return b + easeQuartInOut(t / d) * c;\\n}\\n\";\n\nvar ease_quart_out = \"float easeQuartOut(float t) {\\n  return 1.0 - pow(1.0 - t, 4.0);\\n}\\nfloat easeQuartOut(float t, float b, float c, float d) {\\n  return b + easeQuartOut(t / d) * c;\\n}\\n\";\n\nvar ease_quint_in = \"float easeQuintIn(float t) {\\n    return pow(t, 5.0);\\n}\\nfloat easeQuintIn(float t, float b, float c, float d) {\\n    return b + easeQuintIn(t / d) * c;\\n}\\n\";\n\nvar ease_quint_in_out = \"float easeQuintInOut(float t) {\\n    return (t /= 0.5) < 1.0 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2.0) * t * t * t * t + 2.0);\\n}\\nfloat easeQuintInOut(float t, float b, float c, float d) {\\n    return b + easeQuintInOut(t / d) * c;\\n}\\n\";\n\nvar ease_quint_out = \"float easeQuintOut(float t) {\\n    return (t -= 1.0) * t * t * t * t + 1.0;\\n}\\nfloat easeQuintOut(float t, float b, float c, float d) {\\n    return b + easeQuintOut(t / d) * c;\\n}\\n\";\n\nvar ease_sine_in = \"float easeSineIn(float p) {\\n  return -cos(p * 1.57079632679) + 1.0;\\n}\\nfloat easeSineIn(float t, float b, float c, float d) {\\n  return b + easeSineIn(t / d) * c;\\n}\\n\";\n\nvar ease_sine_in_out = \"float easeSineInOut(float p) {\\n  return -0.5 * (cos(PI * p) - 1.0);\\n}\\nfloat easeSineInOut(float t, float b, float c, float d) {\\n  return b + easeSineInOut(t / d) * c;\\n}\\n\";\n\nvar ease_sine_out = \"float easeSineOut(float p) {\\n  return sin(p * 1.57079632679);\\n}\\nfloat easeSineOut(float t, float b, float c, float d) {\\n  return b + easeSineOut(t / d) * c;\\n}\\n\";\n\nvar quadratic_bezier = \"vec3 quadraticBezier(vec3 p0, vec3 c0, vec3 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\\n}\\nvec2 quadraticBezier(vec2 p0, vec2 c0, vec2 p1, float t) {\\n    float tn = 1.0 - t;\\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\\n}\";\n\nvar quaternion_rotation = \"vec3 rotateVector(vec4 q, vec3 v) {\\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\\n}\\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\\n    float halfAngle = angle * 0.5;\\n    return vec4(axis.xyz * sin(halfAngle), cos(halfAngle));\\n}\\n\";\n\nvar quaternion_slerp = \"vec4 quatSlerp(vec4 q0, vec4 q1, float t) {\\n    float s = 1.0 - t;\\n    float c = dot(q0, q1);\\n    float dir = -1.0;    float sqrSn = 1.0 - c * c;\\n    if (sqrSn > 2.220446049250313e-16) {\\n        float sn = sqrt(sqrSn);\\n        float len = atan(sn, c * dir);\\n        s = sin(s * len) / sn;\\n        t = sin(t * len) / sn;\\n    }\\n    float tDir = t * dir;\\n    return normalize(q0 * s + q1 * tDir);\\n}\\n\";\n\n// generated by scripts/build_shader_chunks.js\n\n\nconst ShaderChunk = {\n  catmull_rom_spline: catmull_rom_spline,\n  cubic_bezier: cubic_bezier,\n  ease_back_in: ease_back_in,\n  ease_back_in_out: ease_back_in_out,\n  ease_back_out: ease_back_out,\n  ease_bezier: ease_bezier,\n  ease_bounce_in: ease_bounce_in,\n  ease_bounce_in_out: ease_bounce_in_out,\n  ease_bounce_out: ease_bounce_out,\n  ease_circ_in: ease_circ_in,\n  ease_circ_in_out: ease_circ_in_out,\n  ease_circ_out: ease_circ_out,\n  ease_cubic_in: ease_cubic_in,\n  ease_cubic_in_out: ease_cubic_in_out,\n  ease_cubic_out: ease_cubic_out,\n  ease_elastic_in: ease_elastic_in,\n  ease_elastic_in_out: ease_elastic_in_out,\n  ease_elastic_out: ease_elastic_out,\n  ease_expo_in: ease_expo_in,\n  ease_expo_in_out: ease_expo_in_out,\n  ease_expo_out: ease_expo_out,\n  ease_quad_in: ease_quad_in,\n  ease_quad_in_out: ease_quad_in_out,\n  ease_quad_out: ease_quad_out,\n  ease_quart_in: ease_quart_in,\n  ease_quart_in_out: ease_quart_in_out,\n  ease_quart_out: ease_quart_out,\n  ease_quint_in: ease_quint_in,\n  ease_quint_in_out: ease_quint_in_out,\n  ease_quint_out: ease_quint_out,\n  ease_sine_in: ease_sine_in,\n  ease_sine_in_out: ease_sine_in_out,\n  ease_sine_out: ease_sine_out,\n  quadratic_bezier: quadratic_bezier,\n  quaternion_rotation: quaternion_rotation,\n  quaternion_slerp: quaternion_slerp,\n\n};\n\n/**\n * A timeline transition segment. An instance of this class is created internally when calling {@link THREE.BAS.Timeline.add}, so you should not use this class directly.\n * The instance is also passed the the compiler function if you register a transition through {@link THREE.BAS.Timeline.register}. There you can use the public properties of the segment to compile the glsl string.\n * @param {string} key A string key generated by the timeline to which this segment belongs. Keys are unique.\n * @param {number} start Start time of this segment in a timeline in seconds.\n * @param {number} duration Duration of this segment in seconds.\n * @param {object} transition Object describing the transition.\n * @param {function} compiler A reference to the compiler function from a transition definition.\n * @constructor\n */\nfunction TimelineSegment(key, start, duration, transition, compiler) {\n  this.key = key;\n  this.start = start;\n  this.duration = duration;\n  this.transition = transition;\n  this.compiler = compiler;\n\n  this.trail = 0;\n}\n\nTimelineSegment.prototype.compile = function() {\n  return this.compiler(this);\n};\n\nObject.defineProperty(TimelineSegment.prototype, 'end', {\n  get: function() {\n    return this.start + this.duration;\n  }\n});\n\n/**\n * A utility class to create an animation timeline which can be baked into a (vertex) shader.\n * By default the timeline supports translation, scale and rotation. This can be extended or overridden.\n * @constructor\n */\nfunction Timeline() {\n  /**\n   * The total duration of the timeline in seconds.\n   * @type {number}\n   */\n  this.duration = 0;\n\n  /**\n   * The name of the value that segments will use to read the time. Defaults to 'tTime'.\n   * @type {string}\n   */\n  this.timeKey = 'tTime';\n\n  this.segments = {};\n  this.__key = 0;\n}\n\n// static definitions map\nTimeline.segmentDefinitions = {};\n\n/**\n * Registers a transition definition for use with {@link THREE.BAS.Timeline.add}.\n * @param {String} key Name of the transition. Defaults include 'scale', 'rotate' and 'translate'.\n * @param {Object} definition\n * @param {Function} definition.compiler A function that generates a glsl string for a transition segment. Accepts a THREE.BAS.TimelineSegment as the sole argument.\n * @param {*} definition.defaultFrom The initial value for a transform.from. For example, the defaultFrom for a translation is THREE.Vector3(0, 0, 0).\n * @static\n */\nTimeline.register = function(key, definition) {\n  Timeline.segmentDefinitions[key] = definition;\n  \n  return definition;\n};\n\n/**\n * Add a transition to the timeline.\n * @param {number} duration Duration in seconds\n * @param {object} transitions An object containing one or several transitions. The keys should match transform definitions.\n * The transition object for each key will be passed to the matching definition's compiler. It can have arbitrary properties, but the Timeline expects at least a 'to', 'from' and an optional 'ease'.\n * @param {number|string} [positionOffset] Position in the timeline. Defaults to the end of the timeline. If a number is provided, the transition will be inserted at that time in seconds. Strings ('+=x' or '-=x') can be used for a value relative to the end of timeline.\n */\nTimeline.prototype.add = function(duration, transitions, positionOffset) {\n  // stop rollup from complaining about eval\n  const _eval = eval;\n  \n  let start = this.duration;\n\n  if (positionOffset !== undefined) {\n    if (typeof positionOffset === 'number') {\n      start = positionOffset;\n    }\n    else if (typeof positionOffset === 'string') {\n      _eval('start' + positionOffset);\n    }\n\n    this.duration = Math.max(this.duration, start + duration);\n  }\n  else {\n    this.duration += duration;\n  }\n\n  let keys = Object.keys(transitions), key;\n\n  for (let i = 0; i < keys.length; i++) {\n    key = keys[i];\n\n    this.processTransition(key, transitions[key], start, duration);\n  }\n};\n\nTimeline.prototype.processTransition = function(key, transition, start, duration) {\n  const definition = Timeline.segmentDefinitions[key];\n\n  let segments = this.segments[key];\n  if (!segments) segments = this.segments[key] = [];\n\n  if (transition.from === undefined) {\n    if (segments.length === 0) {\n      transition.from = definition.defaultFrom;\n    }\n    else {\n      transition.from = segments[segments.length - 1].transition.to;\n    }\n  }\n\n  segments.push(new TimelineSegment((this.__key++).toString(), start, duration, transition, definition.compiler));\n};\n\n/**\n * Compiles the timeline into a glsl string array that can be injected into a (vertex) shader.\n * @returns {Array}\n */\nTimeline.prototype.compile = function() {\n  const c = [];\n\n  const keys = Object.keys(this.segments);\n  let segments;\n\n  for (let i = 0; i < keys.length; i++) {\n    segments = this.segments[keys[i]];\n\n    this.fillGaps(segments);\n\n    segments.forEach(function(s) {\n      c.push(s.compile());\n    });\n  }\n\n  return c;\n};\nTimeline.prototype.fillGaps = function(segments) {\n  if (segments.length === 0) return;\n\n  let s0, s1;\n\n  for (let i = 0; i < segments.length - 1; i++) {\n    s0 = segments[i];\n    s1 = segments[i + 1];\n\n    s0.trail = s1.start - s0.end;\n  }\n\n  // pad last segment until end of timeline\n  s0 = segments[segments.length - 1];\n  s0.trail = this.duration - s0.end;\n};\n\n/**\n * Get a compiled glsl string with calls to transform functions for a given key.\n * The order in which these transitions are applied matters because they all operate on the same value.\n * @param {string} key A key matching a transform definition.\n * @returns {string}\n */\nTimeline.prototype.getTransformCalls = function(key) {\n  let t = this.timeKey;\n\n  return this.segments[key] ?  this.segments[key].map(function(s) {\n    return `applyTransform${s.key}(${t}, transformed);`;\n  }).join('\\n') : '';\n};\n\nconst TimelineChunks = {\n  vec3: function(n, v, p) {\n    const x = (v.x || 0).toPrecision(p);\n    const y = (v.y || 0).toPrecision(p);\n    const z = (v.z || 0).toPrecision(p);\n\n    return `vec3 ${n} = vec3(${x}, ${y}, ${z});`;\n  },\n  vec4: function(n, v, p) {\n    const x = (v.x || 0).toPrecision(p);\n    const y = (v.y || 0).toPrecision(p);\n    const z = (v.z || 0).toPrecision(p);\n    const w = (v.w || 0).toPrecision(p);\n  \n    return `vec4 ${n} = vec4(${x}, ${y}, ${z}, ${w});`;\n  },\n  delayDuration: function(segment) {\n    return `\n    float cDelay${segment.key} = ${segment.start.toPrecision(4)};\n    float cDuration${segment.key} = ${segment.duration.toPrecision(4)};\n    `;\n  },\n  progress: function(segment) {\n    // zero duration segments should always render complete\n    if (segment.duration === 0) {\n      return `float progress = 1.0;`\n    }\n    else {\n      return `\n      float progress = clamp(time - cDelay${segment.key}, 0.0, cDuration${segment.key}) / cDuration${segment.key};\n      ${segment.transition.ease ? `progress = ${segment.transition.ease}(progress${(segment.transition.easeParams ? `, ${segment.transition.easeParams.map((v) => v.toPrecision(4)).join(`, `)}` : ``)});` : ``}\n      `;\n    }\n  },\n  renderCheck: function(segment) {\n    const startTime = segment.start.toPrecision(4);\n    const endTime = (segment.end + segment.trail).toPrecision(4);\n\n    return `if (time < ${startTime} || time > ${endTime}) return;`;\n  }\n};\n\nconst TranslationSegment = {\n  compiler: function(segment) {\n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec3(`cTranslateFrom${segment.key}`, segment.transition.from, 2)}\n    ${TimelineChunks.vec3(`cTranslateTo${segment.key}`, segment.transition.to, 2)}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n    \n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n    \n      v += mix(cTranslateFrom${segment.key}, cTranslateTo${segment.key}, progress);\n    }\n    `;\n  },\n  defaultFrom: new Vector3(0, 0, 0)\n};\n\nTimeline.register('translate', TranslationSegment);\n\nconst ScaleSegment = {\n  compiler: function(segment) {\n    const origin = segment.transition.origin;\n    \n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec3(`cScaleFrom${segment.key}`, segment.transition.from, 2)}\n    ${TimelineChunks.vec3(`cScaleTo${segment.key}`, segment.transition.to, 2)}\n    ${origin ? TimelineChunks.vec3(`cOrigin${segment.key}`, origin, 2) : ''}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n    \n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n    \n      ${origin ? `v -= cOrigin${segment.key};` : ''}\n      v *= mix(cScaleFrom${segment.key}, cScaleTo${segment.key}, progress);\n      ${origin ? `v += cOrigin${segment.key};` : ''}\n    }\n    `;\n  },\n  defaultFrom: new Vector3(1, 1, 1)\n};\n\nTimeline.register('scale', ScaleSegment);\n\nconst RotationSegment = {\n  compiler(segment) {\n    const fromAxisAngle = new Vector4(\n      segment.transition.from.axis.x,\n      segment.transition.from.axis.y,\n      segment.transition.from.axis.z,\n      segment.transition.from.angle\n    );\n  \n    const toAxis = segment.transition.to.axis || segment.transition.from.axis;\n    const toAxisAngle = new Vector4(\n      toAxis.x,\n      toAxis.y,\n      toAxis.z,\n      segment.transition.to.angle\n    );\n  \n    const origin = segment.transition.origin;\n    \n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec4(`cRotationFrom${segment.key}`, fromAxisAngle, 8)}\n    ${TimelineChunks.vec4(`cRotationTo${segment.key}`, toAxisAngle, 8)}\n    ${origin ? TimelineChunks.vec3(`cOrigin${segment.key}`, origin, 2) : ''}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n\n      ${origin ? `v -= cOrigin${segment.key};` : ''}\n      vec3 axis = normalize(mix(cRotationFrom${segment.key}.xyz, cRotationTo${segment.key}.xyz, progress));\n      float angle = mix(cRotationFrom${segment.key}.w, cRotationTo${segment.key}.w, progress);\n      vec4 q = quatFromAxisAngle(axis, angle);\n      v = rotateVector(q, v);\n      ${origin ? `v += cOrigin${segment.key};` : ''}\n    }\n    `;\n  },\n  defaultFrom: {axis: new Vector3(), angle: 0}\n};\n\nTimeline.register('rotate', RotationSegment);\n\nexport { BaseAnimationMaterial, BasicAnimationMaterial, DepthAnimationMaterial, DistanceAnimationMaterial, InstancedPrefabBufferGeometry, LambertAnimationMaterial, ModelBufferGeometry, MultiPrefabBufferGeometry, PhongAnimationMaterial, PointBufferGeometry, PointsAnimationMaterial, PrefabBufferGeometry, RotationSegment, ScaleSegment, ShaderChunk, StandardAnimationMaterial, Timeline, TimelineChunks, TimelineSegment, ToonAnimationMaterial, TranslationSegment, Utils };\n","import { Loader, FileLoader, BufferGeometry, BufferAttribute } from 'three';\n\nconst _taskCache = new WeakMap();\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = '';\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = '';\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD'\n    };\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array'\n    };\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      const taskConfig = {\n        attributeIDs: this.defaultAttributeIDs,\n        attributeTypes: this.defaultAttributeTypes,\n        useUniqueIDs: false\n      };\n      this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n    }, onProgress, onError);\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n\n\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    } //\n\n\n    const taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');\n      }\n    } //\n\n\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength; // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n\n    const geometryPending = this._getWorker(taskID, taskCost).then(_worker => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: 'decode',\n          id: taskID,\n          taskConfig,\n          buffer\n        }, [buffer]); // this.debug();\n      });\n    }).then(message => this._createGeometry(message.geometry)); // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID); // this.debug();\n\n      }\n    }); // Cache the task result.\n\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n\n    return geometryPending;\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n\n    return geometry;\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject);\n    });\n  }\n\n  preload() {\n    this._initDecoder();\n\n    return this;\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending;\n    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n    const librariesPending = [];\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then(libraries => {\n      const jsContent = libraries[0];\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n\n      const fn = DRACOWorker.toString();\n      const body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL);\n        worker._callbacks = {};\n        worker._taskCosts = {};\n        worker._taskLoad = 0;\n        worker.postMessage({\n          type: 'init',\n          decoderConfig: this.decoderConfig\n        });\n\n        worker.onmessage = function (e) {\n          const message = e.data;\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message);\n\n              break;\n\n            case 'error':\n              worker._callbacks[message.id].reject(message);\n\n              break;\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n\n        this.workerPool.push(worker);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n\n  debug() {\n    console.log('Task load: ', this.workerPool.map(worker => worker._taskLoad));\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n\n    this.workerPool.length = 0;\n    return this;\n  }\n\n}\n/* WEB WORKER */\n\n\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n\n  onmessage = function (e) {\n    const message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve\n        /*, reject*/\n        ) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({\n              draco: draco\n            });\n          };\n\n          DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n        });\n        break;\n\n      case 'decode':\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then(module => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map(attr => attr.array.buffer);\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: 'decode',\n              id: message.id,\n              geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\n    }\n\n    const geometry = {\n      index: null,\n      attributes: []\n    }; // Gather all vertex attributes.\n\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID; // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    } // Add index.\n\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n\n    const ptr = draco._malloc(byteLength);\n\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n\n    draco._free(ptr);\n\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n\n    const ptr = draco._malloc(byteLength);\n\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n\n    draco._free(ptr);\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents\n    };\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n\n      case Int8Array:\n        return draco.DT_INT8;\n\n      case Int16Array:\n        return draco.DT_INT16;\n\n      case Int32Array:\n        return draco.DT_INT32;\n\n      case Uint8Array:\n        return draco.DT_UINT8;\n\n      case Uint16Array:\n        return draco.DT_UINT16;\n\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\n\nexport { DRACOLoader };\n","// This file is part of meshoptimizer library and is distributed under the terms of MIT License.\n// Copyright (C) 2016-2020, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)\nconst MeshoptDecoder = (() => {\n  // Built with clang version 11.0.0 (https://github.com/llvm/llvm-project.git 0160ad802e899c2922bc9b29564080c22eb0908c)\n  // Built from meshoptimizer 0.14\n  var wasm_base = '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';\n  var wasm_simd = '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'; // Uses bulk-memory and simd extensions\n\n  var detector = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]); // Used to unpack wasm\n\n  var wasmpack = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);\n\n  if (typeof WebAssembly !== 'object') {\n    // This module requires WebAssembly to function\n    return {\n      supported: false\n    };\n  }\n\n  var wasm = wasm_base;\n\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd;\n    console.log('Warning: meshopt_decoder is using experimental SIMD support');\n  }\n\n  var instance;\n  var promise = WebAssembly.instantiate(unpack(wasm), {}).then(function (result) {\n    instance = result.instance;\n\n    instance.exports.__wasm_call_ctors();\n  });\n\n  function unpack(data) {\n    var result = new Uint8Array(data.length);\n\n    for (var i = 0; i < data.length; ++i) {\n      var ch = data.charCodeAt(i);\n      result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n    }\n\n    var write = 0;\n\n    for (var i = 0; i < data.length; ++i) {\n      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n    }\n\n    return result.buffer.slice(0, write);\n  }\n\n  function decode(fun, target, count, size, source, filter) {\n    var sbrk = instance.exports.sbrk;\n    var count4 = count + 3 & ~3; // pad for SIMD filter\n\n    var tp = sbrk(count4 * size);\n    var sp = sbrk(source.length);\n    var heap = new Uint8Array(instance.exports.memory.buffer);\n    heap.set(source, sp);\n    var res = fun(tp, count, size, sp, source.length);\n\n    if (res == 0 && filter) {\n      filter(tp, count4, size);\n    }\n\n    target.set(heap.subarray(tp, tp + count * size));\n    sbrk(tp - sbrk(0));\n\n    if (res != 0) {\n      throw new Error('Malformed buffer data: ' + res);\n    }\n  }\n\n  var filters = {\n    // legacy index-based enums for glTF\n    0: '',\n    1: 'meshopt_decodeFilterOct',\n    2: 'meshopt_decodeFilterQuat',\n    3: 'meshopt_decodeFilterExp',\n    // string-based enums for glTF\n    NONE: '',\n    OCTAHEDRAL: 'meshopt_decodeFilterOct',\n    QUATERNION: 'meshopt_decodeFilterQuat',\n    EXPONENTIAL: 'meshopt_decodeFilterExp'\n  };\n  var decoders = {\n    // legacy index-based enums for glTF\n    0: 'meshopt_decodeVertexBuffer',\n    1: 'meshopt_decodeIndexBuffer',\n    2: 'meshopt_decodeIndexSequence',\n    // string-based enums for glTF\n    ATTRIBUTES: 'meshopt_decodeVertexBuffer',\n    TRIANGLES: 'meshopt_decodeIndexBuffer',\n    INDICES: 'meshopt_decodeIndexSequence'\n  };\n  return {\n    ready: promise,\n    supported: true,\n    decodeVertexBuffer: function (target, count, size, source, filter) {\n      decode(instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[filters[filter]]);\n    },\n    decodeIndexBuffer: function (target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n    },\n    decodeIndexSequence: function (target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n    },\n    decodeGltfBuffer: function (target, count, size, source, mode, filter) {\n      decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);\n    }\n  };\n})();\n\nexport { MeshoptDecoder };\n","import { Loader, LoaderUtils, FileLoader, Color, SpotLight, PointLight, DirectionalLight, MeshBasicMaterial, MeshPhysicalMaterial, Vector2, TangentSpaceNormalMap, ImageBitmapLoader, TextureLoader, InterleavedBuffer, InterleavedBufferAttribute, BufferAttribute, RGBFormat, LinearFilter, LinearMipmapLinearFilter, RepeatWrapping, PointsMaterial, Material, LineBasicMaterial, MeshStandardMaterial, DoubleSide, sRGBEncoding, PropertyBinding, BufferGeometry, SkinnedMesh, Mesh, LineSegments, Line, LineLoop, Points, Group, PerspectiveCamera, MathUtils, OrthographicCamera, InterpolateLinear, AnimationClip, Bone, Object3D, Matrix4, Skeleton, TriangleFanDrawMode, Interpolant, NearestFilter, NearestMipmapNearestFilter, LinearMipmapNearestFilter, NearestMipmapLinearFilter, ClampToEdgeWrapping, MirroredRepeatWrapping, InterpolateDiscrete, FrontSide, CanvasTexture, TriangleStripDrawMode, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, Box3, Vector3, Sphere } from 'three';\n\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n    this.pluginCallbacks = [];\n    this.register(function (parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsTransmissionExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFLightsExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    let resourcePath;\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== '') {\n      resourcePath = this.path;\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    } // Tells the LoadingManager to track an extra item, which resolves after\n    // the model is fully loaded. This means the count of items loaded will\n    // be incorrect, but ensures manager.onLoad() does not fire early.\n\n\n    this.manager.itemStart(url);\n\n    const _onError = function (e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    };\n\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        scope.parse(data, resourcePath, function (gltf) {\n          onLoad(gltf);\n          scope.manager.itemEnd(url);\n        }, _onError);\n      } catch (e) {\n        _onError(e);\n      }\n    }, onProgress, _onError);\n  }\n\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader;\n    return this;\n  }\n\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n  }\n\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n\n    return this;\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n\n    return this;\n  }\n\n  parse(data, path, onLoad, onError) {\n    let content;\n    const extensions = {};\n    const plugins = {};\n\n    if (typeof data === 'string') {\n      content = data;\n    } else {\n      const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        } catch (error) {\n          if (onError) onError(error);\n          return;\n        }\n\n        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n      } else {\n        content = LoaderUtils.decodeText(new Uint8Array(data));\n      }\n    }\n\n    const json = JSON.parse(content);\n\n    if (json.asset === undefined || json.asset.version[0] < 2) {\n      if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));\n      return;\n    }\n\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || '',\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      plugins[plugin.name] = plugin; // Workaround to avoid determining as unknown extension\n      // in addUnknownExtensionsToUserData().\n      // Remove this workaround if we move all the existing\n      // extension handlers to plugin system\n\n      extensions[plugin.name] = true;\n    }\n\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n            break;\n\n          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n            extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n            break;\n\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n            break;\n\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n            }\n\n        }\n      }\n    }\n\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n\n}\n/* GLTFREGISTRY */\n\n\nfunction GLTFRegistry() {\n  let objects = {};\n  return {\n    get: function (key) {\n      return objects[key];\n    },\n    add: function (key, object) {\n      objects[key] = object;\n    },\n    remove: function (key) {\n      delete objects[key];\n    },\n    removeAll: function () {\n      objects = {};\n    }\n  };\n}\n/*********************************/\n\n/********** EXTENSIONS ***********/\n\n/*********************************/\n\n\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\n};\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\n\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL; // Object3D instance caches\n\n    this.cache = {\n      refs: {},\n      uses: {}\n    };\n  }\n\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = 'light:' + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n    if (dependency) return dependency;\n    const json = parser.json;\n    const extensions = json.extensions && json.extensions[this.name] || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n    const color = new Color(0xffffff);\n    if (lightDef.color !== undefined) color.fromArray(lightDef.color);\n    const range = lightDef.range !== undefined ? lightDef.range : 0;\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      case 'point':\n        lightNode = new PointLight(color);\n        lightNode.distance = range;\n        break;\n\n      case 'spot':\n        lightNode = new SpotLight(color);\n        lightNode.distance = range; // Handle spotlight properties.\n\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type);\n    } // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n\n\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\n    lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex);\n    dependency = Promise.resolve(lightNode);\n    parser.cache.add(cacheKey, dependency);\n    return dependency;\n  }\n\n  createNodeAttachment(nodeIndex) {\n    const self = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n    const lightIndex = lightDef.light;\n    if (lightIndex === undefined) return null;\n    return this._loadLight(lightIndex).then(function (light) {\n      return parser._getNodeRef(self.cache, lightIndex, light);\n    });\n  }\n\n}\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\n\n\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n\n  getMaterialType() {\n    return MeshBasicMaterial;\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n    materialParams.color = new Color(1.0, 1.0, 1.0);\n    materialParams.opacity = 1.0;\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n    }\n\n    return Promise.all(pending);\n  }\n\n}\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\n\n\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n\n    if (extension.clearcoatFactor !== undefined) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n\n    if (extension.clearcoatTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));\n    }\n\n    if (extension.clearcoatRoughnessFactor !== undefined) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n\n    if (extension.clearcoatRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));\n    }\n\n    if (extension.clearcoatNormalTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));\n\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\n        const scale = extension.clearcoatNormalTexture.scale; // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\n        materialParams.clearcoatNormalScale = new Vector2(scale, -scale);\n      }\n    }\n\n    return Promise.all(pending);\n  }\n\n}\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\n\n\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n\n    if (extension.transmissionFactor !== undefined) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n\n    if (extension.transmissionTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));\n    }\n\n    return Promise.all(pending);\n  }\n\n}\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\n\n\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n\n    const extension = textureDef.extensions[this.name];\n    const source = json.images[extension.source];\n    const loader = parser.options.ktx2Loader;\n\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');\n      } else {\n        // Assumes that the extension is optional and that a fallback texture is present\n        return null;\n      }\n    }\n\n    return parser.loadTextureImage(textureIndex, source, loader);\n  }\n\n}\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\n\n\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null) loader = handler;\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, source, loader);\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');\n      } // Fall back to PNG or JPEG.\n\n\n      return parser.loadTexture(textureIndex);\n    });\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image(); // Lossy test image. Support for lossy images doesn't guarantee support for all\n        // WebP images, unfortunately.\n\n        image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1);\n        };\n      });\n    }\n\n    return this.isSupported;\n  }\n\n}\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\n\n\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n      const buffer = this.parser.getDependency('buffer', extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');\n        } else {\n          // Assumes that the extension is optional and that fallback buffer data is present\n          return null;\n        }\n      }\n\n      return Promise.all([buffer, decoder.ready]).then(function (res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n        const result = new ArrayBuffer(count * stride);\n        const source = new Uint8Array(res[0], byteOffset, byteLength);\n        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n        return result;\n      });\n    } else {\n      return null;\n    }\n  }\n\n}\n/* BINARY EXTENSION */\n\n\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = {\n  JSON: 0x4e4f534a,\n  BIN: 0x004e4942\n};\n\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.');\n    }\n\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = LoaderUtils.decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      } // Clients must ignore chunks with unknown types.\n\n\n      chunkIndex += chunkLength;\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.');\n    }\n  }\n\n}\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\n\n\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve) {\n        dracoLoader.decodeDracoFile(bufferView, function (geometry) {\n          for (const attributeName in geometry.attributes) {\n            const attribute = geometry.attributes[attributeName];\n            const normalized = attributeNormalizedMap[attributeName];\n            if (normalized !== undefined) attribute.normalized = normalized;\n          }\n\n          resolve(geometry);\n        }, threeAttributeMap, attributeTypeMap);\n      });\n    });\n  }\n\n}\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\n\n\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n\n  extendTexture(texture, transform) {\n    texture = texture.clone();\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset);\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation;\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale);\n    }\n\n    if (transform.texCoord !== undefined) {\n      console.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\n    }\n\n    texture.needsUpdate = true;\n    return texture;\n  }\n\n}\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n */\n\n/**\n * A sub class of StandardMaterial with some of the functionality\n * changed via the `onBeforeCompile` callback\n * @pailhead\n */\n\n\nclass GLTFMeshStandardSGMaterial extends MeshStandardMaterial {\n  constructor(params) {\n    super();\n    this.isGLTFSpecularGlossinessMaterial = true; //various chunks that need replacing\n\n    const specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\n    const glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\n    const specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\ttexelSpecular = sRGBToLinear( texelSpecular );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\n    const glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\n    const lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.specularRoughness += geometryRoughness;', 'material.specularRoughness = min( material.specularRoughness, 1.0 );', 'material.specularColor = specularFactor;'].join('\\n');\n    const uniforms = {\n      specular: {\n        value: new Color().setHex(0xffffff)\n      },\n      glossiness: {\n        value: 1\n      },\n      specularMap: {\n        value: null\n      },\n      glossinessMap: {\n        value: null\n      }\n    };\n    this._extraUniforms = uniforms;\n\n    this.onBeforeCompile = function (shader) {\n      for (const uniformName in uniforms) {\n        shader.uniforms[uniformName] = uniforms[uniformName];\n      }\n\n      shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n    };\n\n    Object.defineProperties(this, {\n      specular: {\n        get: function () {\n          return uniforms.specular.value;\n        },\n        set: function (v) {\n          uniforms.specular.value = v;\n        }\n      },\n      specularMap: {\n        get: function () {\n          return uniforms.specularMap.value;\n        },\n        set: function (v) {\n          uniforms.specularMap.value = v;\n\n          if (v) {\n            this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\n          } else {\n            delete this.defines.USE_SPECULARMAP;\n          }\n        }\n      },\n      glossiness: {\n        get: function () {\n          return uniforms.glossiness.value;\n        },\n        set: function (v) {\n          uniforms.glossiness.value = v;\n        }\n      },\n      glossinessMap: {\n        get: function () {\n          return uniforms.glossinessMap.value;\n        },\n        set: function (v) {\n          uniforms.glossinessMap.value = v;\n\n          if (v) {\n            this.defines.USE_GLOSSINESSMAP = '';\n            this.defines.USE_UV = '';\n          } else {\n            delete this.defines.USE_GLOSSINESSMAP;\n            delete this.defines.USE_UV;\n          }\n        }\n      }\n    });\n    delete this.metalness;\n    delete this.roughness;\n    delete this.metalnessMap;\n    delete this.roughnessMap;\n    this.setValues(params);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.specularMap = source.specularMap;\n    this.specular.copy(source.specular);\n    this.glossinessMap = source.glossinessMap;\n    this.glossiness = source.glossiness;\n    delete this.metalness;\n    delete this.roughness;\n    delete this.metalnessMap;\n    delete this.roughnessMap;\n    return this;\n  }\n\n}\n\nclass GLTFMaterialsPbrSpecularGlossinessExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n    this.specularGlossinessParams = ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'];\n  }\n\n  getMaterialType() {\n    return GLTFMeshStandardSGMaterial;\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pbrSpecularGlossiness = materialDef.extensions[this.name];\n    materialParams.color = new Color(1.0, 1.0, 1.0);\n    materialParams.opacity = 1.0;\n    const pending = [];\n\n    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n      const array = pbrSpecularGlossiness.diffuseFactor;\n      materialParams.color.fromArray(array);\n      materialParams.opacity = array[3];\n    }\n\n    if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));\n    }\n\n    materialParams.emissive = new Color(0.0, 0.0, 0.0);\n    materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n    materialParams.specular = new Color(1.0, 1.0, 1.0);\n\n    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n      materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n    }\n\n    if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n      const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n      pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));\n      pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));\n    }\n\n    return Promise.all(pending);\n  }\n\n  createMaterial(materialParams) {\n    const material = new GLTFMeshStandardSGMaterial(materialParams);\n    material.fog = true;\n    material.color = materialParams.color;\n    material.map = materialParams.map === undefined ? null : materialParams.map;\n    material.lightMap = null;\n    material.lightMapIntensity = 1.0;\n    material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\n    material.aoMapIntensity = 1.0;\n    material.emissive = materialParams.emissive;\n    material.emissiveIntensity = 1.0;\n    material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\n    material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n    material.bumpScale = 1;\n    material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\n    material.normalMapType = TangentSpaceNormalMap;\n    if (materialParams.normalScale) material.normalScale = materialParams.normalScale;\n    material.displacementMap = null;\n    material.displacementScale = 1;\n    material.displacementBias = 0;\n    material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\n    material.specular = materialParams.specular;\n    material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\n    material.glossiness = materialParams.glossiness;\n    material.alphaMap = null;\n    material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\n    material.envMapIntensity = 1.0;\n    material.refractionRatio = 0.98;\n    return material;\n  }\n\n}\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\n\n\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n\n}\n/*********************************/\n\n/********** INTERPOLATION ********/\n\n/*********************************/\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\n\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  copySampleValue_(index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n    const result = this.resultBuffer,\n          values = this.sampleValues,\n          valueSize = this.valueSize,\n          offset = index * valueSize * 3 + valueSize;\n\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n\n    return result;\n  }\n\n}\n\nGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\nGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\nGLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n  const result = this.resultBuffer;\n  const values = this.sampleValues;\n  const stride = this.valueSize;\n  const stride2 = stride * 2;\n  const stride3 = stride * 3;\n  const td = t1 - t0;\n  const p = (t - t0) / td;\n  const pp = p * p;\n  const ppp = pp * p;\n  const offset1 = i1 * stride3;\n  const offset0 = offset1 - stride3;\n  const s2 = -2 * ppp + 3 * pp;\n  const s3 = ppp - pp;\n  const s0 = 1 - s2;\n  const s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:\n  //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\n  for (let i = 0; i !== stride; i++) {\n    const p0 = values[offset0 + i + stride]; // splineVertex_k\n\n    const m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n\n    const p1 = values[offset1 + i + stride]; // splineVertex_k+1\n\n    const m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n    result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n  }\n\n  return result;\n};\n/*********************************/\n\n/********** INTERNALS ************/\n\n/*********************************/\n\n/* CONSTANTS */\n\n\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  TEXCOORD_0: 'uv',\n  TEXCOORD_1: 'uv2',\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex'\n};\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  translation: 'position',\n  rotation: 'quaternion',\n  weights: 'morphTargetInfluences'\n};\nconst INTERPOLATION = {\n  CUBICSPLINE: undefined,\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n  OPAQUE: 'OPAQUE',\n  MASK: 'MASK',\n  BLEND: 'BLEND'\n};\n/* UTILITY FUNCTIONS */\n\nfunction resolveURL(url, path) {\n  // Invalid URL\n  if (typeof url !== 'string' || url === '') return ''; // Host Relative URL\n\n  if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n    path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n  } // Absolute URL http://,https://,//\n\n\n  if (/^(https?:)?\\/\\//i.test(url)) return url; // Data URI\n\n  if (/^data:.*,.*$/i.test(url)) return url; // Blob URL\n\n  if (/^blob:.*$/i.test(url)) return url; // Relative URL\n\n  return path + url;\n}\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\n\n\nfunction createDefaultMaterial(cache) {\n  if (cache['DefaultMaterial'] === undefined) {\n    cache['DefaultMaterial'] = new MeshStandardMaterial({\n      color: 0xffffff,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide\n    });\n  }\n\n  return cache['DefaultMaterial'];\n}\n\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  // Add unknown glTF extensions to an object's userData.\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === undefined) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\n\n\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== undefined) {\n    if (typeof gltfDef.extras === 'object') {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\n    }\n  }\n}\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\n\n\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (target.POSITION !== undefined) hasMorphPosition = true;\n    if (target.NORMAL !== undefined) hasMorphNormal = true;\n    if (hasMorphPosition && hasMorphNormal) break;\n  }\n\n  if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n\n    if (hasMorphPosition) {\n      const pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n\n    if (hasMorphNormal) {\n      const pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n  }\n\n  return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\n\n\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n\n  if (meshDef.weights !== undefined) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  } // .extras has user-defined data, so check that .extras.targetNames is an array.\n\n\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n    }\n  }\n}\n\nfunction createPrimitiveKey(primitiveDef) {\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  let geometryKey;\n\n  if (dracoExtension) {\n    geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\n  }\n\n  return geometryKey;\n}\n\nfunction createAttributesKey(attributes) {\n  let attributesKey = '';\n  const keys = Object.keys(attributes).sort();\n\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\n  }\n\n  return attributesKey;\n}\n\nfunction getNormalizedComponentScale(constructor) {\n  // Reference:\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n\n    case Uint8Array:\n      return 1 / 255;\n\n    case Int16Array:\n      return 1 / 32767;\n\n    case Uint16Array:\n      return 1 / 65535;\n\n    default:\n      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');\n  }\n}\n/* GLTF PARSER */\n\n\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options; // loader object cache\n\n    this.cache = new GLTFRegistry(); // associations between Three.js objects and glTF elements\n\n    this.associations = new Map(); // BufferGeometry caching\n\n    this.primitiveCache = {}; // Object3D instance caches\n\n    this.meshCache = {\n      refs: {},\n      uses: {}\n    };\n    this.cameraCache = {\n      refs: {},\n      uses: {}\n    };\n    this.lightCache = {\n      refs: {},\n      uses: {}\n    }; // Track node names, to ensure no duplicates\n\n    this.nodeNamesUsed = {}; // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n    // expensive work of uploading a texture to the GPU off the main thread.\n\n    if (typeof createImageBitmap !== 'undefined' && /Firefox/.test(navigator.userAgent) === false) {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager);\n    } else {\n      this.textureLoader = new TextureLoader(this.options.manager);\n    }\n\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new FileLoader(this.options.manager);\n    this.fileLoader.setResponseType('arraybuffer');\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions; // Clear the loader cache\n\n    this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse\n\n    this._invokeAll(function (ext) {\n      return ext._markDefs && ext._markDefs();\n    });\n\n    Promise.all(this._invokeAll(function (ext) {\n      return ext.beforeRoot && ext.beforeRoot();\n    })).then(function () {\n      return Promise.all([parser.getDependencies('scene'), parser.getDependencies('animation'), parser.getDependencies('camera')]);\n    }).then(function (dependencies) {\n      const result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser: parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      Promise.all(parser._invokeAll(function (ext) {\n        return ext.afterRoot && ext.afterRoot(result);\n      })).then(function () {\n        onLoad(result);\n      });\n    }).catch(onError);\n  }\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n\n\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || []; // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints;\n\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    } // Iterate over all nodes, marking references to shared resources,\n    // as well as skeleton joints.\n\n\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n\n      if (nodeDef.mesh !== undefined) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh); // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n\n\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n\n      if (nodeDef.camera !== undefined) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n\n\n  _addNodeRef(cache, index) {\n    if (index === undefined) return;\n\n    if (cache.refs[index] === undefined) {\n      cache.refs[index] = cache.uses[index] = 0;\n    }\n\n    cache.refs[index]++;\n  }\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n\n\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1) return object;\n    const ref = object.clone();\n    ref.name += '_instance_' + cache.uses[index]++;\n    return ref;\n  }\n\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result) return result;\n    }\n\n    return null;\n  }\n\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n    const pending = [];\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result) pending.push(result);\n    }\n\n    return pending;\n  }\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n\n\n  getDependency(type, index) {\n    const cacheKey = type + ':' + index;\n    let dependency = this.cache.get(cacheKey);\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index);\n          break;\n\n        case 'node':\n          dependency = this.loadNode(index);\n          break;\n\n        case 'mesh':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMesh && ext.loadMesh(index);\n          });\n          break;\n\n        case 'accessor':\n          dependency = this.loadAccessor(index);\n          break;\n\n        case 'bufferView':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadBufferView && ext.loadBufferView(index);\n          });\n          break;\n\n        case 'buffer':\n          dependency = this.loadBuffer(index);\n          break;\n\n        case 'material':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMaterial && ext.loadMaterial(index);\n          });\n          break;\n\n        case 'texture':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadTexture && ext.loadTexture(index);\n          });\n          break;\n\n        case 'skin':\n          dependency = this.loadSkin(index);\n          break;\n\n        case 'animation':\n          dependency = this.loadAnimation(index);\n          break;\n\n        case 'camera':\n          dependency = this.loadCamera(index);\n          break;\n\n        default:\n          throw new Error('Unknown type: ' + type);\n      }\n\n      this.cache.add(cacheKey, dependency);\n    }\n\n    return dependency;\n  }\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n\n\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n      dependencies = Promise.all(defs.map(function (def, index) {\n        return parser.getDependency(type, index);\n      }));\n      this.cache.add(type, dependencies);\n    }\n\n    return dependencies;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader = this.fileLoader;\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n    } // If present, GLB container is required to be the first buffer.\n\n\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n\n    const options = this.options;\n    return new Promise(function (resolve, reject) {\n      loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n\n\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n    const accessorDef = this.json.accessors[accessorIndex];\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      // Ignore empty accessors, which may be used to declare runtime\n      // information about attributes coming from another source (e.g. Draco\n      // compression extension).\n      return Promise.resolve(null);\n    }\n\n    const pendingBufferViews = [];\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      const bufferView = bufferViews[0];\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.\n\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.\n\n          ib = new InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n\n        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized);\n      } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\n\n      if (accessorDef.sparse !== undefined) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n        }\n\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n        }\n      }\n\n      return bufferAttribute;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture>}\n   */\n\n\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const source = json.images[textureDef.source];\n    let loader = this.textureLoader;\n\n    if (source.uri) {\n      const handler = options.manager.getHandler(source.uri);\n      if (handler !== null) loader = handler;\n    }\n\n    return this.loadTextureImage(textureIndex, source, loader);\n  }\n\n  loadTextureImage(textureIndex, source, loader) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const URL = self.URL || self.webkitURL;\n    let sourceURI = source.uri;\n    let isObjectURL = false;\n    let hasAlpha = true;\n    if (source.mimeType === 'image/jpeg') hasAlpha = false;\n\n    if (source.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n      sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n        if (source.mimeType === 'image/png') {\n          // Inspect the PNG 'IHDR' chunk to determine whether the image could have an\n          // alpha channel. This check is conservative — the image could have an alpha\n          // channel with all values == 1, and the indexed type (colorType == 3) only\n          // sometimes contains alpha.\n          //\n          // https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\n          const colorType = new DataView(bufferView, 25, 1).getUint8(0, false);\n          hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;\n        }\n\n        isObjectURL = true;\n        const blob = new Blob([bufferView], {\n          type: source.mimeType\n        });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    } else if (source.uri === undefined) {\n      throw new Error('THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView');\n    }\n\n    return Promise.resolve(sourceURI).then(function (sourceURI) {\n      return new Promise(function (resolve, reject) {\n        let onLoad = resolve;\n\n        if (loader.isImageBitmapLoader === true) {\n          onLoad = function (imageBitmap) {\n            resolve(new CanvasTexture(imageBitmap));\n          };\n        }\n\n        loader.load(resolveURL(sourceURI, options.path), onLoad, undefined, reject);\n      });\n    }).then(function (texture) {\n      // Clean up resources and configure Texture.\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n\n      texture.flipY = false;\n      if (textureDef.name) texture.name = textureDef.name; // When there is definitely no alpha channel in the texture, set RGBFormat to save space.\n\n      if (!hasAlpha) texture.format = RGBFormat;\n      const samplers = json.samplers || {};\n      const sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;\n      parser.associations.set(texture, {\n        type: 'textures',\n        index: textureIndex\n      });\n      return texture;\n    });\n  }\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise}\n   */\n\n\n  assignTexture(materialParams, mapName, mapDef) {\n    const parser = this;\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n      // However, we will copy UV set 0 to UV set 1 on demand for aoMap\n      if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {\n        console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\n\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n\n      materialParams[mapName] = texture;\n    });\n  }\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n\n\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n    const useVertexTangents = geometry.attributes.tangent !== undefined;\n    const useVertexColors = geometry.attributes.color !== undefined;\n    const useFlatShading = geometry.attributes.normal === undefined;\n    const useSkinning = mesh.isSkinnedMesh === true;\n    const useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;\n    const useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n    if (mesh.isPoints) {\n      const cacheKey = 'PointsMaterial:' + material.uuid;\n      let pointsMaterial = this.cache.get(cacheKey);\n\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial();\n        Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = 'LineBasicMaterial:' + material.uuid;\n      let lineMaterial = this.cache.get(cacheKey);\n\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial();\n        Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        this.cache.add(cacheKey, lineMaterial);\n      }\n\n      material = lineMaterial;\n    } // Clone the material if it will be modified\n\n\n    if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {\n      let cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n      if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';\n      if (useSkinning) cacheKey += 'skinning:';\n      if (useVertexTangents) cacheKey += 'vertex-tangents:';\n      if (useVertexColors) cacheKey += 'vertex-colors:';\n      if (useFlatShading) cacheKey += 'flat-shading:';\n      if (useMorphTargets) cacheKey += 'morph-targets:';\n      if (useMorphNormals) cacheKey += 'morph-normals:';\n      let cachedMaterial = this.cache.get(cacheKey);\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useSkinning) cachedMaterial.skinning = true;\n        if (useVertexColors) cachedMaterial.vertexColors = true;\n        if (useFlatShading) cachedMaterial.flatShading = true;\n        if (useMorphTargets) cachedMaterial.morphTargets = true;\n        if (useMorphNormals) cachedMaterial.morphNormals = true;\n\n        if (useVertexTangents) {\n          cachedMaterial.vertexTangents = true; // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n\n        this.cache.add(cacheKey, cachedMaterial);\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n\n      material = cachedMaterial;\n    } // workarounds for mesh and geometry\n\n\n    if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n      geometry.setAttribute('uv2', geometry.attributes.uv);\n    }\n\n    mesh.material = material;\n  }\n\n  getMaterialType()\n  /* materialIndex */\n  {\n    return MeshStandardMaterial;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n\n\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n    const pending = [];\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n      const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n      materialType = sgExtension.getMaterialType();\n      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new Color(1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\n      }\n\n      materialType = this._invokeOne(function (ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\n      });\n      pending.push(Promise.all(this._invokeAll(function (ext) {\n        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n      })));\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide;\n    }\n\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706\n\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture)); // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\n      materialParams.normalScale = new Vector2(1, -1);\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        materialParams.normalScale.set(materialDef.normalTexture.scale, -materialDef.normalTexture.scale);\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {\n      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));\n    }\n\n    return Promise.all(pending).then(function () {\n      let material;\n\n      if (materialType === GLTFMeshStandardSGMaterial) {\n        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n      } else {\n        material = new materialType(materialParams);\n      }\n\n      if (materialDef.name) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\n      if (material.map) material.map.encoding = sRGBEncoding;\n      if (material.emissiveMap) material.emissiveMap.encoding = sRGBEncoding;\n      assignExtrasToUserData(material, materialDef);\n      parser.associations.set(material, {\n        type: 'materials',\n        index: materialIndex\n      });\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  }\n  /** When Object3D instances are targeted by animation, they need unique names. */\n\n\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '');\n    let name = sanitizedName;\n\n    for (let i = 1; this.nodeNamesUsed[name]; ++i) {\n      name = sanitizedName + '_' + i;\n    }\n\n    this.nodeNamesUsed[name] = true;\n    return name;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n\n\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache = this.primitiveCache;\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n\n    const pending = [];\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry\n\n      const cached = cache[cacheKey];\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);\n        } // Cache this geometry\n\n\n        cache[cacheKey] = {\n          primitive: primitive,\n          promise: geometryPromise\n        };\n        pending.push(geometryPromise);\n      }\n    }\n\n    return Promise.all(pending);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n\n\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n    const pending = [];\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);\n      pending.push(material);\n    }\n\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function (results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n      const meshes = [];\n\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i]; // 1. create Mesh\n\n        let mesh;\n        const material = materials[i];\n\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);\n\n          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\n            // we normalize floating point skin weight array to fix malformed assets (see #15319)\n            // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n            mesh.normalizeSkinWeights();\n          }\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material);\n        } else {\n          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n        }\n\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n\n        mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex);\n        assignExtrasToUserData(mesh, meshDef);\n        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n\n      if (meshes.length === 1) {\n        return meshes[0];\n      }\n\n      const group = new Group();\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n\n      return group;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n\n\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.');\n      return;\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Object>}\n   */\n\n\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n    const skinEntry = {\n      joints: skinDef.joints\n    };\n\n    if (skinDef.inverseBindMatrices === undefined) {\n      return Promise.resolve(skinEntry);\n    }\n\n    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n      skinEntry.inverseBindMatrices = accessor;\n      return skinEntry;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n\n\n  loadAnimation(animationIndex) {\n    const json = this.json;\n    const animationDef = json.animations[animationIndex];\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\n      const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n      const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n      pendingNodes.push(this.getDependency('node', name));\n      pendingInputAccessors.push(this.getDependency('accessor', input));\n      pendingOutputAccessors.push(this.getDependency('accessor', output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n\n    return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n      const tracks = [];\n\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n        if (node === undefined) continue;\n        node.updateMatrix();\n        node.matrixAutoUpdate = true;\n        let TypedKeyframeTrack;\n\n        switch (PATH_PROPERTIES[target.path]) {\n          case PATH_PROPERTIES.weights:\n            TypedKeyframeTrack = NumberKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES.rotation:\n            TypedKeyframeTrack = QuaternionKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES.position:\n          case PATH_PROPERTIES.scale:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack;\n            break;\n        }\n\n        const targetName = node.name ? node.name : node.uuid;\n        const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;\n        const targetNames = [];\n\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n          // Node may be a Group (glTF mesh with several primitives) or a Mesh.\n          node.traverse(function (object) {\n            if (object.isMesh === true && object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid);\n            }\n          });\n        } else {\n          targetNames.push(targetName);\n        }\n\n        let outputArray = outputAccessor.array;\n\n        if (outputAccessor.normalized) {\n          const scale = getNormalizedComponentScale(outputArray.constructor);\n          const scaled = new Float32Array(outputArray.length);\n\n          for (let j = 0, jl = outputArray.length; j < jl; j++) {\n            scaled[j] = outputArray[j] * scale;\n          }\n\n          outputArray = scaled;\n        }\n\n        for (let j = 0, jl = targetNames.length; j < jl; j++) {\n          const track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.\n\n          if (sampler.interpolation === 'CUBICSPLINE') {\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n              // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n              // must be divided by three to get the interpolant's sampleSize argument.\n              return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n            }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\n\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n          }\n\n          tracks.push(track);\n        }\n      }\n\n      const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n      return new AnimationClip(name, undefined, tracks);\n    });\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    if (nodeDef.mesh === undefined) return null;\n    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh); // if weights are provided on the node, override weights on the mesh.\n\n\n      if (nodeDef.weights !== undefined) {\n        node.traverse(function (o) {\n          if (!o.isMesh) return;\n\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n\n\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex]; // reserve node's name before its dependencies, so the root has the intended name.\n\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';\n    return function () {\n      const pending = [];\n\n      const meshPromise = parser._invokeOne(function (ext) {\n        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n      });\n\n      if (meshPromise) {\n        pending.push(meshPromise);\n      }\n\n      if (nodeDef.camera !== undefined) {\n        pending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n        }));\n      }\n\n      parser._invokeAll(function (ext) {\n        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n      }).forEach(function (promise) {\n        pending.push(promise);\n      });\n\n      return Promise.all(pending);\n    }().then(function (objects) {\n      let node; // .isBone isn't in glTF spec. See ._markDefs\n\n      if (nodeDef.isBone === true) {\n        node = new Bone();\n      } else if (objects.length > 1) {\n        node = new Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new Object3D();\n      }\n\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n\n      if (nodeDef.matrix !== undefined) {\n        const matrix = new Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation);\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n\n      parser.associations.set(node, {\n        type: 'nodes',\n        index: nodeIndex\n      });\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n\n\n  loadScene(sceneIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this; // Loader returns Group, not Scene.\n    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\n    const scene = new Group();\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n    assignExtrasToUserData(scene, sceneDef);\n    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n    const nodeIds = sceneDef.nodes || [];\n    const pending = [];\n\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\n    }\n\n    return Promise.all(pending).then(function () {\n      return scene;\n    });\n  }\n\n}\n\nfunction buildNodeHierachy(nodeId, parentObject, json, parser) {\n  const nodeDef = json.nodes[nodeId];\n  return parser.getDependency('node', nodeId).then(function (node) {\n    if (nodeDef.skin === undefined) return node; // build skeleton here as well\n\n    let skinEntry;\n    return parser.getDependency('skin', nodeDef.skin).then(function (skin) {\n      skinEntry = skin;\n      const pendingJoints = [];\n\n      for (let i = 0, il = skinEntry.joints.length; i < il; i++) {\n        pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\n      }\n\n      return Promise.all(pendingJoints);\n    }).then(function (jointNodes) {\n      node.traverse(function (mesh) {\n        if (!mesh.isMesh) return;\n        const bones = [];\n        const boneInverses = [];\n\n        for (let j = 0, jl = jointNodes.length; j < jl; j++) {\n          const jointNode = jointNodes[j];\n\n          if (jointNode) {\n            bones.push(jointNode);\n            const mat = new Matrix4();\n\n            if (skinEntry.inverseBindMatrices !== undefined) {\n              mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n            }\n\n            boneInverses.push(mat);\n          } else {\n            console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\n          }\n        }\n\n        mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);\n      });\n      return node;\n    });\n  }).then(function (node) {\n    // build node hierachy\n    parentObject.add(node);\n    const pending = [];\n\n    if (nodeDef.children) {\n      const children = nodeDef.children;\n\n      for (let i = 0, il = children.length; i < il; i++) {\n        const child = children[i];\n        pending.push(buildNodeHierachy(child, node, json, parser));\n      }\n    }\n\n    return Promise.all(pending);\n  });\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\n\n\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const box = new Box3();\n\n  if (attributes.POSITION !== undefined) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n    const min = accessor.min;\n    const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n    if (min !== undefined && max !== undefined) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));\n\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n      return;\n    }\n  } else {\n    return;\n  }\n\n  const targets = primitiveDef.targets;\n\n  if (targets !== undefined) {\n    const maxDisplacement = new Vector3();\n    const vector = new Vector3();\n\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n\n      if (target.POSITION !== undefined) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n        if (min !== undefined && max !== undefined) {\n          // we need to get max of absolute components because target weight is [-1,1]\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n            vector.multiplyScalar(boxScale);\n          } // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\n\n          maxDisplacement.max(vector);\n        } else {\n          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n        }\n      }\n    } // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\n\n    box.expandByVector(maxDisplacement);\n  }\n\n  geometry.boundingBox = box;\n  const sphere = new Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\n\n\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const pending = [];\n\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.\n\n    if (threeAttributeName in geometry.attributes) continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n\n  if (primitiveDef.indices !== undefined && !geometry.index) {\n    const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n      geometry.setIndex(accessor);\n    });\n    pending.push(accessor);\n  }\n\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function () {\n    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {Number} drawMode\n * @return {BufferGeometry}\n */\n\n\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  let index = geometry.getIndex(); // generate index if not present\n\n  if (index === null) {\n    const indices = [];\n    const position = geometry.getAttribute('position');\n\n    if (position !== undefined) {\n      for (let i = 0; i < position.count; i++) {\n        indices.push(i);\n      }\n\n      geometry.setIndex(indices);\n      index = geometry.getIndex();\n    } else {\n      console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n      return geometry;\n    }\n  } //\n\n\n  const numberOfTriangles = index.count - 2;\n  const newIndices = [];\n\n  if (drawMode === TriangleFanDrawMode) {\n    // gl.TRIANGLE_FAN\n    for (let i = 1; i <= numberOfTriangles; i++) {\n      newIndices.push(index.getX(0));\n      newIndices.push(index.getX(i));\n      newIndices.push(index.getX(i + 1));\n    }\n  } else {\n    // gl.TRIANGLE_STRIP\n    for (let i = 0; i < numberOfTriangles; i++) {\n      if (i % 2 === 0) {\n        newIndices.push(index.getX(i));\n        newIndices.push(index.getX(i + 1));\n        newIndices.push(index.getX(i + 2));\n      } else {\n        newIndices.push(index.getX(i + 2));\n        newIndices.push(index.getX(i + 1));\n        newIndices.push(index.getX(i));\n      }\n    }\n  }\n\n  if (newIndices.length / 3 !== numberOfTriangles) {\n    console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n  } // build final geometry\n\n\n  const newGeometry = geometry.clone();\n  newGeometry.setIndex(newIndices);\n  return newGeometry;\n}\n\nexport { GLTFLoader };\n","import { GLTFLoader, DRACOLoader, MeshoptDecoder } from 'three-stdlib';\nimport { useLoader } from '@react-three/fiber';\n\n// @ts-ignore\n\nfunction extensions(useDraco, useMeshopt, extendLoader) {\n  return loader => {\n    if (extendLoader) {\n      extendLoader(loader);\n    }\n\n    if (useDraco) {\n      const dracoLoader = new DRACOLoader();\n      dracoLoader.setDecoderPath(typeof useDraco === 'string' ? useDraco : 'https://www.gstatic.com/draco/v1/decoders/');\n      loader.setDRACOLoader(dracoLoader);\n    }\n\n    if (useMeshopt) {\n      loader.setMeshoptDecoder(MeshoptDecoder);\n    }\n  };\n}\n\nfunction useGLTF(path, useDraco = true, useMeshOpt = true, extendLoader) {\n  const gltf = useLoader(GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));\n  return gltf;\n}\n\nuseGLTF.preload = (path, useDraco = true, useMeshOpt = true, extendLoader) => useLoader.preload(GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader)); // @ts-expect-error new in r3f 7.0.5\n\n\nuseGLTF.clear = input => useLoader.clear(GLTFLoader, input);\n\nexport { useGLTF };\n"],"sourceRoot":""}